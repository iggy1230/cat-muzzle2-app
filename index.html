<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Cat Muzzle AI - Professional v94 Final Stable</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #020202; color: #eee; text-align: center; margin: 0; padding: 10px; }
        .card { background: #111; padding: 25px; border-radius: 28px; max-width: 850px; margin: auto; border: 1px solid #333; box-shadow: 0 40px 100px rgba(0,0,0,0.9); }
        #log { background: #000; color: #00ff66; font-family: 'Consolas', monospace; font-size: 11px; padding: 10px; height: 120px; overflow-y: auto; text-align: left; border-radius: 12px; margin-bottom: 20px; border: 1px solid #222; white-space: pre-wrap; }
        .preview-box { position: relative; width: 100%; background: #000; border-radius: 20px; border: 1px solid #333; overflow: hidden; display: flex; flex-direction: column; align-items: center; min-height: 400px; }
        canvas { width: 100%; height: auto; display: block; image-rendering: -webkit-optimize-contrast; }
        .btn { padding: 18px 36px; background: #6200ee; color: white; border: none; border-radius: 15px; font-weight: bold; cursor: pointer; font-size: 16px; width: 85%; margin: 10px 0; transition: 0.3s; }
        .btn:hover:not(:disabled) { background: #7c4dff; transform: translateY(-2px); }
        .btn:disabled { background: #333; color: #777; cursor: wait; }
        .progress-box { width: 90%; margin: 15px auto; display: none; }
        .progress-bar { width: 100%; background: #222; height: 10px; border-radius: 4px; overflow: hidden; }
        #progressFill { width: 0%; background: #00e676; height: 100%; }
        #downloadBtn { background: #00c853; display: none; }
    </style>
</head>
<body>
    <div class="card">
        <h2 style="margin-top:0;">üê± CAT MUZZLE STUDIO <span style="font-size:12px; color:#7c4dff;">v94 FINAL-STABLE</span></h2>
        <div id="log">„É≠„Ç∞: „Ç∑„Çπ„ÉÜ„É†Ëµ∑Âãï‰∏≠...</div>
        
        <input type="file" id="fileInput" accept="image/*,video/*" hidden>
        <button id="uploadBtn" class="btn" disabled>„Ç®„É≥„Ç∏„É≥„Çí„É≠„Éº„Éâ‰∏≠...</button>

        <div class="progress-box" id="progressBox">
            <div class="progress-bar"><div id="progressFill"></div></div>
            <div id="progressLabel" style="font-size:13px; margin-top:8px; color:#00e676;">Ëß£Êûê‰∏≠...</div>
        </div>

        <div class="preview-box">
            <canvas id="canvas"></canvas>
            <video id="video" playsinline style="display:none;"></video>
        </div>

        <button id="downloadBtn" class="btn">üì• Èü≥Â£∞ÂÖ•„ÇäÂãïÁîª„ÇíÁîüÊàê„Åó„Å¶‰øùÂ≠ò</button>
    </div>

    <script type="module">
        import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('video');
        const fileInput = document.getElementById('fileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const progressBox = document.getElementById('progressBox');
        const progressFill = document.getElementById('progressFill');
        const progressLabel = document.getElementById('progressLabel');
        const logArea = document.getElementById('log');

        let faceLandmarker;
        let muzzleImg = new Image(); muzzleImg.src = "muzzle.png"; 

        let frameData = []; 
        let isExporting = false;
        let audioCtx, audioSource, audioDest;

        function addLog(msg) {
            logArea.innerText += `> ${msg}\n`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        async function init() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `./models/face_landmarker.task`, delegate: "GPU" },
                    runningMode: "IMAGE", numFaces: 2, minFaceDetectionConfidence: 0.15
                });
                addLog("„Ç∑„Çπ„ÉÜ„É†Ê∫ñÂÇôÂÆå‰∫Ü„ÄÇ");
                uploadBtn.disabled = false;
                uploadBtn.onclick = () => fileInput.click();
            } catch (e) { addLog("ÂàùÊúüÂåñÂ§±Êïó: " + e.message); }
        }

        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            downloadBtn.style.display = "none";
            startAnalysis(URL.createObjectURL(file));
        };

        // --- 1. ‰∫ãÂâçËß£Êûê„Éï„Çß„Éº„Ç∫ ---
        async function startAnalysis(url) {
            addLog("Ëß£Êûê„ÇíÈñãÂßã...");
            video.src = url; video.load();
            video.onloadedmetadata = async () => {
                canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                frameData = []; progressBox.style.display = "block";
                const fps = 12, totalSteps = Math.floor(video.duration * fps);

                for (let i = 0; i <= totalSteps; i++) {
                    video.currentTime = i / fps;
                    await new Promise(r => {
                        const t = setTimeout(r, 1000);
                        video.onseeked = () => { clearTimeout(t); r(); };
                    });
                    await new Promise(r => requestAnimationFrame(r));
                    const res = faceLandmarker.detect(video);
                    frameData.push({ time: video.currentTime, faces: (res.faceLandmarks || []).map(lm => extractMetrics(lm)) });
                    progressFill.style.width = (i/totalSteps*100) + "%";
                    progressLabel.innerText = `Ëß£Êûê‰∏≠: ${Math.floor(i/totalSteps*100)}%`;
                }

                finalizeTracks();
                addLog("Ëß£ÊûêÂÆå‰∫Ü„ÄÇ‰øùÂ≠ò„Éú„Çø„É≥„ÇíÊ∫ñÂÇô„Åó„Åæ„Åó„Åü„ÄÇ");
                progressBox.style.display = "none";
                downloadBtn.style.display = "block";
                video.currentTime = 0;
                video.muted = true; // „Éó„É¨„Éì„É•„ÉºÊôÇ„ÅØ„Éü„É•„Éº„Éà
                video.play();
                requestAnimationFrame(liveLoop);
            };
        }

        function extractMetrics(lm) {
            const nx = (lm[4].x + lm[1].x + lm[195].x)/3, ny = (lm[4].y + lm[1].y + lm[195].y)/3;
            const w = Math.abs(lm[454].x - lm[234].x);
            return { nx, ny, scale: w, angle: Math.atan2((lm[263].y - lm[33].y), (lm[263].x - lm[33].x)), yaw: (lm[4].x - (lm[33].x+lm[263].x)*0.5)/(w*0.5||1), pitch: Math.atan2(lm[152].z-lm[4].z, lm[152].y-lm[4].y) };
        }

        function finalizeTracks() {
            let tracks = [[], []]; let lastData = [null, null];
            frameData.forEach((frame, idx) => {
                let current = frame.faces, assigned = [null, null];
                if (idx === 0) { current.sort((a,b) => a.nx - b.nx); assigned[0]=current[0]; assigned[1]=current[1]; }
                else {
                    current.forEach(face => {
                        let bestId = -1, minDist = 0.2;
                        for(let id=0; id<2; id++) {
                            if (lastData[id]) {
                                const d = Math.hypot(face.nx - lastData[id].nx, face.ny - lastData[id].ny);
                                if (d < minDist) { minDist = d; bestId = id; }
                            }
                        }
                        if (bestId !== -1 && !assigned[bestId]) assigned[bestId] = face;
                        else if (!assigned[0]) assigned[0] = face; else if (!assigned[1]) assigned[1] = face;
                    });
                }
                for(let id=0; id<2; id++) {
                    if (!assigned[id] && lastData[id] && lastData[id].life > 0) assigned[id] = { ...lastData[id], life: lastData[id].life - 1, isGhost: true };
                    else if (assigned[id]) { assigned[id].life = 60; assigned[id].isGhost = false; }
                    tracks[id].push(assigned[id]);
                    if (assigned[id]) lastData[id] = assigned[id];
                }
            });
            tracks.forEach(track => {
                for (let i = 1; i < track.length - 1; i++) {
                    if (!track[i]) {
                        let p1 = i - 1; while(p1 >= 0 && !track[p1]) p1--;
                        let p2 = i; while(p2 < track.length && !track[p2]) p2++;
                        if (p1 >= 0 && p2 < track.length) track[i] = lerpPro(track[p1], track[p2], (i - p1) / (p2 - p1));
                    }
                }
            });
            frameData.forEach((f, i) => f.faces = [tracks[0][i], tracks[1][i]]);
        }
        function lerpPro(a, b, t) { return { nx: a.nx+(b.nx-a.nx)*t, ny: a.ny+(b.ny-a.ny)*t, scale: a.scale+(b.scale-a.scale)*t, angle: a.angle, yaw: a.yaw, pitch: a.pitch, isGhost: true }; }

        function liveLoop() {
            if (video.paused || video.ended || isExporting) return;
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const frame = frameData.find(f => f.time >= video.currentTime) || frameData[frameData.length-1];
            if (frame) frame.faces.forEach(face => { if (face) drawMuzzle(face); });
            requestAnimationFrame(liveLoop);
        }

        function drawMuzzle(f) {
            const px = f.nx * canvas.width, py = f.ny * canvas.height;
            const aspect = muzzleImg.width / muzzleImg.height;
            const yaw = Math.max(-1.2, Math.min(1.2, f.yaw));
            const baseSizePx = f.scale * canvas.width * 0.9, dw = baseSizePx, dh = dw / aspect;
            const sxL = 1 - Math.max(0, -yaw)*0.55, sxR = 1 - Math.max(0, yaw)*0.55;
            const scaleY = (1 - Math.abs(yaw) * 0.15) * (1.0 + (f.pitch - 0.5) * 0.35);
            ctx.save();
            ctx.translate(px + yaw*dw*0.16, py); ctx.rotate(f.angle || 0);
            const imgW = muzzleImg.width, imgH = muzzleImg.height;
            ctx.save(); ctx.scale(sxL, scaleY);
            ctx.drawImage(muzzleImg, 0, 0, imgW/2, imgH, -dw/2, -dh/2 + (dh*0.1), dw/2, dh);
            ctx.restore();
            ctx.save(); ctx.scale(sxR, scaleY);
            ctx.drawImage(muzzleImg, imgW/2, 0, imgW/2, imgH, 0, -dh/2 + (dh*0.1), dw/2, dh);
            ctx.restore(); ctx.restore();
        }

        // --- 2. ‰øÆÊ≠£ÁâàÔºöÂÆüÊôÇÈñì‰øùÂ≠ò„É≠„Ç∏„ÉÉ„ÇØ (1KBÂïèÈ°å„ÇíËß£Ê±∫) ---
        downloadBtn.onclick = async () => {
            addLog("Êõ∏„ÅçÂá∫„Åó„ÇíÈñãÂßã... ÂãïÁîª„ÅåÊúÄÂæå„Åæ„ÅßÂÜçÁîü„Åï„Çå„Çã„ÅÆ„Çí„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ");
            downloadBtn.disabled = true;
            isExporting = true;
            
            // AudioË®≠ÂÆö„ÅÆÂÜçÂà©Áî®„Ç¨„Éº„Éâ
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                audioDest = audioCtx.createMediaStreamDestination();
                audioSource = audioCtx.createMediaElementSource(video);
                audioSource.connect(audioDest);
                audioSource.connect(audioCtx.destination);
            }
            await audioCtx.resume();

            // Êò†ÂÉè„Çπ„Éà„É™„Éº„É† (ÊâãÂãï„Åß„ÅØ„Å™„ÅèËá™Âãï„Ç≠„É£„Éó„ÉÅ„É£„Å´„Åô„Çã)
            const videoStream = canvas.captureStream(30); 
            const combined = new MediaStream([
                ...videoStream.getVideoTracks(),
                ...audioDest.stream.getAudioTracks()
            ]);

            let mimeType = 'video/webm;codecs=vp9';
            if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'video/webm';

            const recorder = new MediaRecorder(combined, { mimeType, videoBitsPerSecond: 10000000 });
            const localChunks = [];
            
            recorder.ondataavailable = e => { if(e.data.size > 0) localChunks.push(e.data); };
            recorder.onstop = () => {
                addLog("Blob„Éï„Ç°„Ç§„É´„ÇíÁîüÊàê‰∏≠...");
                const blob = new Blob(localChunks, { type: mimeType });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = "cat_muzzle_studio.webm";
                a.click();
                addLog("‰øùÂ≠òÂÆå‰∫Ü„Åó„Åæ„Åó„ÅüÔºÅ");
                downloadBtn.disabled = false;
                isExporting = false;
                video.muted = true; // ÂÜç„Å≥„Éó„É¨„Éì„É•„ÉºÁî®„Å´Ê∂àÈü≥
            };

            // Èå≤ÁîªÊ∫ñÂÇôÔºöÊúÄÂàù„Å´Êàª„Åô
            video.pause();
            video.currentTime = 0;
            video.muted = false; // Èü≥„ÇíÂá∫„Åô„Åì„Å®„ÅßAudioContext„Å´ÊµÅ„Åô
            video.playbackRate = 1.0;

            await new Promise(r => video.onseeked = r);
            
            recorder.start();
            video.play();

            // Èå≤Áîª‰∏≠„ÅÆÊèèÁîª„É´„Éº„Éó (liveLoop„ÇíÊµÅÁî®„Åõ„ÅöÂ∞ÇÁî®„ÅßÂõû„Åô)
            const exportRender = () => {
                if (!isExporting) return;
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                const frame = frameData.find(f => f.time >= video.currentTime) || frameData[frameData.length-1];
                if (frame) frame.faces.forEach(face => { if (face) drawMuzzle(face); });
                
                if (video.ended) {
                    setTimeout(() => recorder.stop(), 500); // ‰ΩôË£ï„ÇíÊåÅ„Å£„Å¶ÂÅúÊ≠¢
                } else {
                    requestAnimationFrame(exportRender);
                }
            };
            exportRender();
        };

        init();
    </script>
</body>
</html>