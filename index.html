<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Hybrid Cat Muzzle AI (YOLO + MediaPipe)</title>
    <style>
        body { font-family: sans-serif; background: #1a1a1a; color: #fff; text-align: center; margin: 0; padding: 20px; }
        .card { background: #2d2d2d; padding: 20px; border-radius: 20px; max-width: 700px; margin: auto; }
        #log { background: #000; color: #0f0; font-family: monospace; font-size: 11px; padding: 10px; height: 80px; overflow-y: auto; text-align: left; border-radius: 8px; margin: 10px 0; }
        .preview-box { position: relative; border: 2px solid #444; border-radius: 12px; overflow: hidden; background: #000; }
        canvas { max-width: 100%; height: auto; }
        .btn { padding: 15px 30px; background: #7c4dff; color: white; border: none; border-radius: 10px; font-weight: bold; cursor: pointer; margin: 10px; width: 80%; }
        .btn:disabled { background: #444; opacity: 0.6; }
    </style>
</head>
<body>
    <div class="card">
        <h2>ğŸ± HYBRID MUZZLE AI</h2>
        <div id="log">ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ä¸­...</div>
        
        <input type="file" id="fileInput" accept="image/*,video/*" hidden>
        <button id="uploadBtn" class="btn" disabled>ã‚¨ãƒ³ã‚¸ãƒ³èª­ã¿è¾¼ã¿ä¸­...</button>

        <div class="preview-box">
            <canvas id="canvas"></canvas>
            <video id="video" playsinline muted style="display:none;"></video>
        </div>
    </div>

    <script type="module">
        import { FaceDetector, FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('video');
        const fileInput = document.getElementById('fileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const logArea = document.getElementById('log');

        let detector;    // YOLOå½¹ (é¡”æ¤œå‡º)
        let landmarker;  // ç²¾å¯†è¨ˆæ¸¬å½¹ (ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯)
        let muzzleImg = new Image();
        muzzleImg.src = "muzzle.png";

        function addLog(msg) {
            logArea.innerText += `> ${msg}\n`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        async function init() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                
                // 1. YOLOå½¹: Face Detector (é«˜é€Ÿãƒ»åºƒç¯„å›²)
                detector = await FaceDetector.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_detector/blaze_face_short_range/float16/1/blaze_face_short_range.task` },
                    runningMode: "VIDEO"
                });

                // 2. è§£æå½¹: Face Landmarker (ç²¾å¯†ãƒ»ROIå†…)
                landmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task` },
                    runningMode: "VIDEO",
                    numFaces: 1 // ROIã”ã¨ã«1äºº
                });

                addLog("YOLO + MediaPipe ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ã‚¨ãƒ³ã‚¸ãƒ³èµ·å‹•å®Œäº†");
                uploadBtn.disabled = false;
                uploadBtn.innerText = "å†™çœŸãƒ»å‹•ç”»ã‚’é¸æŠ";
                uploadBtn.onclick = () => fileInput.click();
            } catch (e) { addLog("åˆæœŸåŒ–å¤±æ•—: " + e.message); }
        }

        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            if (file.type.startsWith('image/')) {
                const img = new Image();
                img.onload = () => {
                    canvas.width = img.width; canvas.height = img.height;
                    processFrame(img);
                };
                img.src = url;
            } else {
                video.src = url;
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    video.play();
                    renderLoop();
                };
            }
        };

        async function renderLoop() {
            if (video.paused || video.ended) return;
            await processFrame(video);
            requestAnimationFrame(renderLoop);
        }

        async function processFrame(source) {
            // èƒŒæ™¯æç”»
            ctx.drawImage(source, 0, 0, canvas.width, canvas.height);

            // --- STEP 1: YOLOå½¹ (é¡”ã®ä½ç½®ã‚’ç‰¹å®š) ---
            const detectionResult = await detector.detectForVideo(source, performance.now());
            
            if (detectionResult.detections) {
                // æœ€å¤§2äººã¾ã§
                for (let i = 0; i < Math.min(detectionResult.detections.length, 2); i++) {
                    const face = detectionResult.detections[i];
                    const bbox = face.boundingBox;

                    // --- STEP 2: ROIã®åˆ‡ã‚Šå‡ºã— (å°‘ã—ä½™è£•ã‚’æŒãŸã›ã‚‹) ---
                    const padding = 0.2;
                    const roi = {
                        x: Math.max(0, bbox.originX - bbox.width * padding),
                        y: Math.max(0, bbox.originY - bbox.height * padding),
                        w: Math.min(canvas.width, bbox.width * (1 + padding * 2)),
                        h: Math.min(canvas.height, bbox.height * (1 + padding * 2))
                    };

                    // ROIå†…ã§ã®ç²¾å¯†è§£æã®ãŸã‚ã€Canvasã‹ã‚‰ä¸€æ™‚çš„ã«ROIã‚’æŠ½å‡º
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = roi.w; tempCanvas.height = roi.h;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(canvas, roi.x, roi.y, roi.w, roi.h, 0, 0, roi.w, roi.h);

                    // --- STEP 3: è§£æå½¹ (ROIå†…ã®ç²¾å¯†ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯) ---
                    const landmarkResult = await landmarker.detectForVideo(tempCanvas, performance.now());

                    if (landmarkResult.faceLandmarks && landmarkResult.faceLandmarks.length > 0) {
                        // åº§æ¨™ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«å¤‰æ›ã—ã¦æç”»
                        drawHybridMuzzle(landmarkResult.faceLandmarks[0], roi);
                    }
                }
            }
        }

        function drawHybridMuzzle(landmarks, roi) {
            // ROIå†…ã®ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ã‚’ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«åº§æ¨™ã¸å¤‰æ›
            const toGlobal = (lm) => ({
                x: roi.x + (lm.x * roi.w),
                y: roi.y + (lm.y * roi.h),
                z: lm.z // Zã¯ã‚¹ã‚±ãƒ¼ãƒ«ç”¨ãªã®ã§ãã®ã¾ã¾
            });

            const noseTip = toGlobal(landmarks[4]);
            const jawL = toGlobal(landmarks[234]);
            const jawR = toGlobal(landmarks[454]);
            const eyeL = toGlobal(landmarks[33]);
            const eyeR = toGlobal(landmarks[263]);

            // 3D Perspective ãƒ­ã‚¸ãƒƒã‚¯ (å‰å›ã®æ”¹å–„ç‰ˆ)
            const faceCenterX = (jawL.x + jawR.x) / 2;
            const faceWidth2D = Math.abs(jawR.x - jawL.x);
            const yawFactor = (noseTip.x - faceCenterX) / (faceWidth2D / 2);
            const faceWidth3D = Math.hypot(jawR.x - jawL.x, (jawR.z - jawL.z) * roi.w);
            const angle = Math.atan2(eyeR.y - eyeL.y, eyeR.x - eyeL.x);

            const expansion = 1.0 + Math.abs(yawFactor) * 0.3;
            const baseSize = faceWidth3D * 0.8 * expansion;
            const squeezeFactor = Math.max(0.4, Math.cos(yawFactor * (Math.PI / 2.2)));
            
            const targetWidth = baseSize * squeezeFactor;
            const targetHeight = targetWidth / (muzzleImg.width / muzzleImg.height);

            // æ‰‹å‰ã¨å¥¥ã‚’éš ã™å¼·åŒ–ã‚ªãƒ•ã‚»ãƒƒãƒˆ
            const totalXOffset = yawFactor * baseSize * 0.35;

            ctx.save();
            ctx.translate(noseTip.x, noseTip.y);
            ctx.rotate(angle);
            ctx.drawImage(
                muzzleImg, 
                -targetWidth / 2 + totalXOffset, 
                -targetHeight / 2 + (targetHeight * 0.15), 
                targetWidth, 
                targetHeight
            );
            ctx.restore();
        }

        init();
    </script>
</body>
</html>