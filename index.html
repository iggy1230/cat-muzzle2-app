<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Cat Muzzle AI - Professional Studio v136 Stable Export</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #0a0a0a; color: #eee; text-align: center; margin: 0; padding: 10px; }
        .card { background: #1a1a1a; padding: 25px; border-radius: 24px; max-width: 850px; margin: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.5); }
        #log { background: #000; color: #00ff66; font-family: 'Consolas', monospace; font-size: 11px; padding: 10px; height: 120px; overflow-y: auto; text-align: left; border-radius: 12px; margin-bottom: 20px; border: 1px solid #333; white-space: pre-wrap; }
        .preview-box { position: relative; width: 100%; background: #000; border-radius: 16px; border: 1px solid #333; overflow: hidden; display: flex; flex-direction: column; align-items: center; min-height: 400px; }
        canvas { width: 100%; height: auto; display: block; image-rendering: -webkit-optimize-contrast; }
        .btn { padding: 16px 32px; background: #6200ee; color: white; border: none; border-radius: 12px; font-weight: bold; cursor: pointer; font-size: 16px; width: 85%; margin: 10px 0; transition: 0.3s; }
        .btn:hover:not(:disabled) { background: #7c4dff; transform: translateY(-2px); }
        .btn:disabled { background: #333; color: #777; cursor: wait; }
        .progress-box { width: 90%; margin: 15px auto; display: none; }
        .progress-bar { width: 100%; background: #333; height: 10px; border-radius: 5px; overflow: hidden; }
        #progressFill { width: 0%; background: #00e676; height: 100%; transition: width 0.2s; }
        #progressLabel { font-size:13px; margin-top:8px; color:#00e676; font-weight:bold; }
        #downloadBtn { background: #00c853; display: none; }
        #replayBtn { background: #007bff; display: none; }
    </style>
</head>
<body>
    <div class="card">
        <h2 style="margin-top:0;">üê± CAT MUZZLE STUDIO <span style="font-size:12px; color:#7c4dff;">v136 FINAL-STABLE</span></h2>
        <div id="log">„É≠„Ç∞: „Ç∑„Çπ„ÉÜ„É†Ëµ∑Âãï‰∏≠...</div>
        
        <input type="file" id="fileInput" accept="image/*,video/*" hidden>
        <button id="uploadBtn" class="btn" disabled>„Ç®„É≥„Ç∏„É≥„Çí„É≠„Éº„Éâ‰∏≠...</button>

        <div class="progress-box" id="progressBox">
            <div class="progress-bar"><div id="progressFill"></div></div>
            <div id="progressLabel">Ê∫ñÂÇô‰∏≠...</div>
        </div>

        <div class="preview-box">
            <canvas id="canvas"></canvas>
            <video id="video" playsinline muted style="display:none;"></video>
        </div>

        <button id="replayBtn" class="btn">üîÑ „ÇÇ„ÅÜ‰∏ÄÂ∫¶ÂÜçÁîü</button>
        <button id="downloadBtn" class="btn">üì• ÂãïÁîª„Çí‰øùÂ≠ò„Åô„Çã</button>
    </div>

    <script type="module">
        import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('video');
        const fileInput = document.getElementById('fileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const replayBtn = document.getElementById('replayBtn');
        const progressBox = document.getElementById('progressBox');
        const progressFill = document.getElementById('progressFill');
        const progressLabel = document.getElementById('progressLabel');
        const logArea = document.getElementById('log');

        let faceLandmarker, muzzleImg = new Image(); muzzleImg.src = "muzzle.png"; 
        let frameData = [], isLooping = false, isExporting = false;
        let globalAudioCtx, globalAudioDest, globalAudioSource;
        const SCAN_FPS = 12;

        function addLog(msg) { logArea.innerText += `> ${msg}\n`; logArea.scrollTop = logArea.scrollHeight; }

        async function init() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `./models/face_landmarker.task`, delegate: "GPU" },
                    runningMode: "IMAGE", numFaces: 2, minFaceDetectionConfidence: 0.1
                });
                addLog("„Ç∑„Çπ„ÉÜ„É†Ê∫ñÂÇôÂÆå‰∫Ü„ÄÇv124Á≤æÂ∫¶Áâà„ÄÇ");
                uploadBtn.disabled = false; uploadBtn.innerText = "ÂãïÁîª„ÇíÈÅ∏Êäû„Åó„Å¶ÈñãÂßã";
                uploadBtn.onclick = () => fileInput.click();
            } catch (e) { addLog("ÂàùÊúüÂåñÂ§±Êïó: " + e.message); }
        }

        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            downloadBtn.style.display = "none"; replayBtn.style.display = "none";
            if (file.type.startsWith('image/')) processImage(URL.createObjectURL(file));
            else startV124EnhancedAnalysis(URL.createObjectURL(file));
        };

        // --- 1. v124 Á≤æÂØÜËß£Êûê„É≠„Ç∏„ÉÉ„ÇØ ---
        async function startV124EnhancedAnalysis(url) {
            addLog("ÊâãÈ†Ü1: ÂÖ®Á∑®„Åã„Çâ„Éô„Çπ„Éà„Ç∑„Éß„ÉÉ„Éà„ÇíËá™ÂãïÊ§úÁ¥¢‰∏≠...");
            video.src = url; video.load();
            video.onloadedmetadata = async () => {
                canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                frameData = []; progressBox.style.display = "block";
                
                let bestScore = -1;
                let goldenAnchors = [null, null];
                const searchInterval = 1.0; 
                for (let t = 0; t < video.duration; t += searchInterval) {
                    video.currentTime = t;
                    await waitSeek(800);
                    const res = faceLandmarker.detect(video);
                    if (res.faceLandmarks && res.faceLandmarks.length >= 1) {
                        let currentScore = res.faceLandmarks.length * 100;
                        res.faceLandmarks.forEach(lm => currentScore += Math.abs(lm[454].x - lm[234].x) * 50);
                        if (currentScore > bestScore) {
                            bestScore = currentScore;
                            const sorted = [...res.faceLandmarks].sort((a,b) => a[4].x - b[4].x);
                            goldenAnchors = sorted.map(lm => ({ x: lm[4].x, y: lm[4].y }));
                        }
                    }
                    progressFill.style.width = Math.floor((t / video.duration) * 100) + "%";
                }
                if (!goldenAnchors[0]) goldenAnchors = [{x:0.3, y:0.5}, {x:0.7, y:0.5}];

                addLog("ÊâãÈ†Ü2: „Ç∫„Éº„É†Á≤æÂØÜËß£Êûê„ÇíÂÆüË°å‰∏≠...");
                const zCanvas = document.createElement('canvas'); zCanvas.width = 640; zCanvas.height = 640;
                const zCtx = zCanvas.getContext('2d');
                const totalSteps = Math.floor(video.duration * SCAN_FPS);

                for (let i = 0; i <= totalSteps; i++) {
                    const ts = i / SCAN_FPS;
                    video.currentTime = ts;
                    await waitSeek(1000);
                    await new Promise(r => requestAnimationFrame(r));

                    let foundInFrame = [];
                    try {
                        for (let id = 0; id < 2; id++) {
                            const anchor = goldenAnchors[id];
                            const rw = canvas.width * 0.45, rh = canvas.height * 0.55;
                            const rx = Math.max(0, Math.min(canvas.width - rw, anchor.x * canvas.width - rw/2));
                            const ry = Math.max(0, Math.min(canvas.height - rh, anchor.y * canvas.height - rh/2));
                            zCtx.clearRect(0,0,640,640);
                            zCtx.filter = "brightness(1.3) contrast(1.6)";
                            zCtx.drawImage(video, rx, ry, rw, rh, 0, 0, 640, 640);
                            const results = faceLandmarker.detect(zCanvas);
                            if (results.faceLandmarks && results.faceLandmarks[0]) {
                                let metrics = extractMetrics(results.faceLandmarks[0]);
                                foundInFrame.push({
                                    px: rx + (metrics.nx_local * rw),
                                    py: ry + (metrics.ny_local * rh),
                                    pScale: metrics.s_local * rw,
                                    angle: metrics.angle,
                                    yaw: metrics.yaw,
                                    pitch: metrics.pitch,
                                    lane: id
                                });
                            }
                        }
                    } catch(e) {}
                    frameData.push({ time: ts, faces: foundInFrame });
                    progressFill.style.width = Math.floor((i / totalSteps) * 100) + "%";
                    if (i % 5 === 0) await new Promise(r => setTimeout(r, 1));
                }
                finalizeTracks();
                addLog("ÂÖ®Ëß£ÊûêÂÆå‰∫Ü„ÄÇ");
                progressBox.style.display = "none"; downloadBtn.style.display = "block";
                startPlayback();
            };
        }

        async function waitSeek(ms) {
            return new Promise(res => {
                const t = setTimeout(() => res(video.readyState >= 2), ms);
                video.onseeked = () => { clearTimeout(t); res(true); };
            });
        }

        function extractMetrics(lm) {
            const nx = lm[4].x * 0.55 + lm[1].x * 0.30 + lm[195].x * 0.15;
            const ny = lm[4].y * 0.45 + lm[1].y * 0.40 + lm[195].y * 0.15;
            const w = Math.abs(lm[454].x - lm[234].x);
            const pitch = (Math.abs(lm[13].y - lm[4].y) / (Math.abs(lm[10].y - lm[152].y) || 0.1) - 0.32) * 2.2;
            return { nx_local: nx, ny_local: ny, s_local: w, pitch, angle: Math.atan2((lm[263].y-lm[33].y),(lm[263].x-lm[33].x)), yaw: (lm[4].x - (lm[33].x+lm[263].x)*0.5)/(w*0.5||1) };
        }

        function finalizeTracks() {
            let tracks = [[], []]; let lastValid = [null, null];
            frameData.forEach((frame, idx) => {
                let assigned = [null, null];
                frame.faces.forEach(f => { if (!assigned[f.lane]) assigned[f.lane] = f; });
                for(let id=0; id<2; id++) {
                    let f = assigned[id]; let prev = lastValid[id];
                    if (f && prev) {
                        f.yaw = prev.yaw + Math.max(-0.08, Math.min(0.08, f.yaw-prev.yaw));
                        f.pitch = prev.pitch + Math.max(-0.08, Math.min(0.08, f.pitch-prev.pitch));
                        let dAng = f.angle - prev.angle;
                        while(dAng > Math.PI) dAng -= Math.PI * 2; while(dAng < -Math.PI) dAng += Math.PI * 2;
                        f.angle = prev.angle + Math.max(-0.12, Math.min(0.12, dAng));
                    }
                    if (!f && prev && prev.life > 0) assigned[id] = { ...prev, life: prev.life - 1, isGhost: true };
                    else if (f) { f.life = 180; f.isGhost = false; }
                    tracks[id].push(assigned[id]); if (assigned[id]) lastValid[id] = assigned[id];
                }
            });
            tracks.forEach(t => {
                for (let i = 1; i < t.length - 1; i++) {
                    if (!t[i]) {
                        let p = i - 1, n = i + 1; while(n < t.length && !t[n]) n++;
                        if (t[p] && t[n] && (n-p)<450) {
                            const r = (i-p)/(n-p);
                            t[i] = { px: t[p].px+(t[n].px-t[p].px)*r, py: t[p].py+(t[n].py-t[p].py)*r, pScale: t[p].pScale+(t[n].pScale-t[p].pScale)*r, angle: t[p].angle, yaw: t[p].yaw, pitch: t[p].pitch, isGhost: true };
                        }
                    }
                }
            });
            frameData.forEach((f, i) => f.optimized = [tracks[0][i], tracks[1][i]]);
        }

        function startPlayback() { video.currentTime = 0; video.play(); isLooping = true; requestAnimationFrame(liveLoop); }
        video.onended = () => { isLooping = false; replayBtn.style.display = "block"; };
        replayBtn.onclick = () => { replayBtn.style.display = "none"; startPlayback(); };

        function liveLoop() {
            if (!isLooping || isExporting) return;
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const frame = frameData.find(f => f.time >= video.currentTime) || frameData[frameData.length-1];
            if (frame && frame.optimized) frame.optimized.forEach(face => { if (face) drawFinalMuzzle(face); });
            requestAnimationFrame(liveLoop);
        }

        function drawFinalMuzzle(f) {
            const px = f.px, py = f.py;
            const dw = f.pScale * 0.95, dh = dw / (muzzleImg.width/muzzleImg.height);
            const yaw = Math.max(-1.2, Math.min(1.2, f.yaw));
            const upBias = Math.max(0, f.pitch) * dw * 0.18;
            const sxL = 1-Math.max(0,-yaw)*0.55, sxR = 1-Math.max(0,yaw)*0.55;
            const scaleY = (1-Math.abs(yaw)*0.15)*(1+(f.pitch-0.5)*0.35);
            ctx.save();
            ctx.translate(px + yaw*dw*0.16, py - upBias); ctx.rotate(f.angle);
            ctx.globalAlpha = 1.0;
            const imgW=muzzleImg.width, imgH=muzzleImg.height;
            ctx.save(); ctx.scale(sxL, scaleY); ctx.drawImage(muzzleImg, 0,0,imgW/2,imgH, -dw/2,-dh/2+(dh*0.1), dw/2,dh); ctx.restore();
            ctx.save(); ctx.scale(sxR, scaleY); ctx.drawImage(muzzleImg, imgW/2,0,imgW/2,imgH, 0,-dh/2+(dh*0.1), dw/2,dh); ctx.restore();
            ctx.restore();
        }

        // --- 2. ‰øÆÊ≠£ÁâàÔºöÈâÑÂ£Å„ÅÆ„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÁô∫ÁÅ´„É≠„Ç∏„ÉÉ„ÇØ ---
        downloadBtn.onclick = async () => {
            addLog("ÂãïÁîª„ÅÆÊõ∏„ÅçÂá∫„Åó„ÇíÈñãÂßã„Åó„Åæ„Åô„ÄÇ");
            downloadBtn.disabled = true; isExporting = true; isLooping = false;
            video.pause(); progressBox.style.display = "block";

            try {
                if (!globalAudioCtx) {
                    globalAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    globalAudioDest = globalAudioCtx.createMediaStreamDestination();
                    globalAudioSource = globalAudioCtx.createMediaElementSource(video);
                    globalAudioSource.connect(globalAudioDest);
                    globalAudioSource.connect(globalAudioCtx.destination);
                }
                await globalAudioCtx.resume();

                const videoStream = canvas.captureStream(30);
                const combinedStream = new MediaStream([...videoStream.getVideoTracks(), ...globalAudioDest.stream.getAudioTracks()]);
                
                // „Éñ„É©„Ç¶„Ç∂‰∫íÊèõÊÄß„ÅÆÈ´ò„ÅÑÂΩ¢Âºè
                let mimeType = 'video/webm;codecs=vp9';
                if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'video/mp4';

                const recorder = new MediaRecorder(combinedStream, { mimeType, videoBitsPerSecond: 12000000 });
                const localChunks = [];
                recorder.ondataavailable = e => { if(e.data.size > 0) localChunks.push(e.data); };
                
                // ‚òÖ ‰øÆÊ≠£ÁÇπÔºöÁ¢∫ÂÆü„Å´Áô∫ÁÅ´„Åô„Çã onstop
                recorder.onstop = async () => {
                    addLog("„Éï„Ç°„Ç§„É´„ÇíÊúÄÁµÇÊßãÊàê„Åó„Å¶„ÅÑ„Åæ„Åô...");
                    await new Promise(r => setTimeout(r, 2500)); // „É°„É¢„É™Êï¥ÁêÜ„ÅÆÂæÖÊ©ü

                    const blob = new Blob(localChunks, { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = "cat_muzzle_result.mp4";
                    document.body.appendChild(a); // DOM„Å´ËøΩÂä†
                    
                    setTimeout(() => {
                        a.click();
                        addLog("„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÇíÈñãÂßã„Åó„Åæ„Åó„ÅüÔºÅ");
                        window.URL.revokeObjectURL(url);
                        document.body.removeChild(a);
                        downloadBtn.disabled = false; isExporting = false;
                        progressBox.style.display = "none"; video.muted = true;
                    }, 500);
                };

                addLog("Á≠âÂÄçÈÄüÈå≤Áîª‰∏≠... „Åù„ÅÆ„Åæ„Åæ„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ");
                video.currentTime = 0; video.muted = false;
                await waitSeek(2000);
                recorder.start(); video.play();

                const exportUpdate = () => {
                    if (!isExporting) return;
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    const frame = frameData.find(f => f.time >= video.currentTime) || frameData[frameData.length-1];
                    if (frame && frame.optimized) frame.optimized.forEach(face => { if (face) drawFinalMuzzle(face); });
                    const percent = Math.floor((video.currentTime / video.duration) * 100);
                    progressFill.style.width = percent + "%";
                    progressLabel.innerText = `Êõ∏„ÅçÂá∫„Åó‰∏≠: ${percent}%`;
                    if (video.ended) { setTimeout(() => recorder.stop(), 1500); }
                    else { requestAnimationFrame(exportUpdate); }
                };
                exportUpdate();
            } catch (err) {
                addLog("„Ç®„É©„Éº: " + err.message);
                downloadBtn.disabled = false; isExporting = false;
            }
        };

        async function processImage(url) { /* ÈùôÊ≠¢ÁîªÁî® */ }
        init();
    </script>
</body>
</html>