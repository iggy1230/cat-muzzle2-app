<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Cat Muzzle AI - Professional v60 Local-Link</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #0a0a0a; color: #eee; text-align: center; margin: 0; padding: 20px; }
        .card { background: #1a1a1a; padding: 25px; border-radius: 24px; max-width: 850px; margin: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.8); border: 1px solid #333; }
        #log { background: #000; color: #00ff66; font-family: monospace; font-size: 11px; padding: 12px; height: 110px; overflow-y: auto; text-align: left; border-radius: 12px; margin-bottom: 20px; border: 1px solid #222; white-space: pre-wrap; }
        .preview-box { position: relative; width: 100%; background: #000; border-radius: 16px; border: 1px solid #333; overflow: hidden; display: flex; flex-direction: column; align-items: center; }
        canvas { width: 100%; height: auto; display: block; }
        .btn { padding: 18px 36px; background: #6200ee; color: white; border: none; border-radius: 14px; font-weight: bold; cursor: pointer; font-size: 16px; width: 90%; margin: 10px 0; transition: 0.3s; }
        .btn:hover:not(:disabled) { background: #7c4dff; }
        .btn:disabled { background: #333; color: #777; cursor: wait; }
        .progress-box { width: 90%; margin: 15px auto; display: none; }
        .progress-bar { width: 100%; background: #333; height: 10px; border-radius: 5px; overflow: hidden; }
        #progressFill { width: 0%; background: #00e676; height: 100%; transition: width 0.2s; }
    </style>
    <!-- ONNX Runtime Web (ÂÆâÂÆöÁâà) -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.1/dist/ort.min.js"></script>
</head>
<body>
    <div class="card">
        <h2 style="margin-top:0;">üê± CAT MUZZLE STUDIO <span style="font-size:12px; color:#7c4dff;">v60 LOCAL-LINK</span></h2>
        <div id="log">„É≠„Ç∞: „Ç∑„Çπ„ÉÜ„É†Ëµ∑Âãï‰∏≠...</div>
        
        <input type="file" id="fileInput" accept="image/*,video/*" hidden>
        <button id="uploadBtn" class="btn" disabled>„Ç®„É≥„Ç∏„É≥„Çí„É≠„Éº„Éâ‰∏≠...</button>

        <div class="progress-box" id="progressBox">
            <div class="progress-bar"><div id="progressFill"></div></div>
            <div id="progressLabel" style="font-size:13px; margin-top:8px; color:#00e676; font-weight:bold;">YOLOv8 + MediaPipe Ëß£Êûê‰∏≠...</div>
        </div>

        <div class="preview-box">
            <canvas id="canvas"></canvas>
            <video id="video" playsinline muted style="display:none;"></video>
        </div>

        <button id="downloadBtn" class="btn" style="background:#00c853; display:none;">üì• ÁµêÊûú„Çí‰øùÂ≠ò„Åô„Çã</button>
    </div>

    <script type="module">
        import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('video');
        const fileInput = document.getElementById('fileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const progressBox = document.getElementById('progressBox');
        const progressFill = document.getElementById('progressFill');
        const logArea = document.getElementById('log');

        let yoloSession, mpLandmarker;
        let muzzleImg = new Image(); muzzleImg.src = "muzzle.png"; 
        let frameSequence = []; 

        function addLog(msg) {
            logArea.innerText += `> ${msg}\n`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        async function init() {
            try {
                addLog("1/2: YOLOv8n-face (ONNX) „É≠„Éº„Éâ‰∏≠...");
                // Áõ∏ÂØæ„Éë„Çπ„ÇíÁ¢∫ÂÆü„Å´Ëß£Ê±∫
                yoloSession = await ort.InferenceSession.create('./models/yolov8n-face.onnx', { executionProviders: ['wasm'] });
                
                addLog("2/2: MediaPipe Landmarker „É≠„Éº„Éâ‰∏≠...");
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                mpLandmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `./models/face_landmarker.task`, delegate: "GPU" },
                    runningMode: "IMAGE", numFaces: 1
                });

                addLog("„Ç∑„Çπ„ÉÜ„É†Ê∫ñÂÇôÂÆå‰∫Ü„ÄÇ„É≠„Éº„Ç´„É´„Çµ„Éº„Éê„ÉºÁµåÁî±„Åß„ÅÆÂÆüË°å„ÇíÁ¢∫Ë™ç„Åó„Åæ„Åó„Åü„ÄÇ");
                uploadBtn.disabled = false;
                uploadBtn.innerText = "ÂãïÁîª„ÉªÂÜôÁúü„ÇíÈÅ∏Êäû„Åó„Å¶ÈñãÂßã";
                uploadBtn.onclick = () => fileInput.click();
            } catch (e) { 
                addLog("ÂàùÊúüÂåñÂ§±Êïó: " + e.message);
                addLog("„ÄêÈáçË¶Å„Äë„Éï„Ç°„Ç§„É´„Çí„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„Åß„ÅØ„Å™„Åè„ÄÅ„É≠„Éº„Ç´„É´„Çµ„Éº„Éê„Éº(VS Code Live ServerÁ≠â)„ÅßÈñã„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
            }
        }

        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            startHybridAnalysis(URL.createObjectURL(file));
        };

        async function startHybridAnalysis(url) {
            addLog("Á≤æÂØÜËß£Êûê„Éó„É≠„Çª„Çπ„ÇíÈñãÂßã...");
            video.src = url; video.load();
            video.onloadedmetadata = async () => {
                canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                frameSequence = []; progressBox.style.display = "block";
                
                const fps = 30, totalFrames = Math.floor(video.duration * fps);
                const roiCanvas = document.createElement('canvas');
                const rCtx = roiCanvas.getContext('2d');

                for (let i = 0; i <= totalFrames; i++) {
                    video.currentTime = i / fps;
                    await new Promise(r => { video.onseeked = r; setTimeout(r, 800); });
                    await new Promise(r => requestAnimationFrame(r));

                    // A. YOLOv8 Êé®Ë´ñ
                    const yoloResults = await runYoloV8(video);
                    let facesInFrame = [];

                    for (const box of yoloResults.slice(0, 2)) {
                        const pad = 0.3;
                        const rx = Math.max(0, box.x1 - box.w * pad);
                        const ry = Math.max(0, box.y1 - box.h * pad);
                        const rw = Math.min(canvas.width - rx, box.w * (1 + pad * 2));
                        const rh = Math.min(canvas.height - ry, box.h * (1 + pad * 2));

                        roiCanvas.width = rw; roiCanvas.height = rh;
                        rCtx.drawImage(video, rx, ry, rw, rh, 0, 0, rw, rh);

                        const lmRes = mpLandmarker.detect(roiCanvas);
                        if (lmRes.faceLandmarks && lmRes.faceLandmarks[0]) {
                            let f = extractMetrics(lmRes.faceLandmarks[0]);
                            f.px = rx + (f.nx * rw); f.py = ry + (f.ny * rh);
                            f.pScale = f.scale * rw; f.type = 'mp';
                            facesInFrame.push(f);
                        } else {
                            // „É©„É≥„Éâ„Éû„Éº„ÇØÊ∂àÂ§±ÊôÇ„ÅØYOLO„ÅÆÈºª(landmarks[2])„Çí‰ΩøÁî®
                            facesInFrame.push({
                                px: box.noseX, py: box.noseY, pScale: box.w * 0.85,
                                angle: 0, yaw: (box.nx > 0.5 ? 0.8 : -0.8), pitch: 0.5, type: 'yolo'
                            });
                        }
                    }
                    frameSequence.push({ time: video.currentTime, faces: facesInFrame });
                    progressFill.style.width = (i / totalFrames * 100) + "%";
                    if (i % 10 === 0) await new Promise(r => setTimeout(r, 1));
                }
                finalizeTracks();
                addLog("Ëß£Êûê„ÉªË£úÈñìÂÆå‰∫Ü„ÄÇ");
                progressBox.style.display = "none";
                downloadBtn.style.display = "block";
                video.currentTime = 0; video.play();
                requestAnimationFrame(renderLoop);
            };
        }

        async function runYoloV8(source) {
            const size = 640;
            const off = document.createElement('canvas'); off.width = size; off.height = size;
            const oCtx = off.getContext('2d');
            oCtx.drawImage(source, 0, 0, size, size);
            const imgData = oCtx.getImageData(0, 0, size, size);
            const input = new Float32Array(size * size * 3);
            for (let i = 0; i < size * size; i++) {
                input[i] = imgData.data[i * 4] / 255.0;
                input[i + size*size] = imgData.data[i * 4 + 1] / 255.0;
                input[i + 2*size*size] = imgData.data[i * 4 + 2] / 255.0;
            }
            const output = await yoloSession.run({ images: new ort.Tensor('float32', input, [1, 3, size, size]) });
            const data = output.output0.data; // [1, 16, 8400]

            let boxes = [];
            for (let i = 0; i < 8400; i++) {
                const score = data[4 * 8400 + i];
                if (score > 0.45) {
                    const w = data[2 * 8400 + i] * (canvas.width / size);
                    const h = data[3 * 8400 + i] * (canvas.height / size);
                    const cx = data[0 * 8400 + i] * (canvas.width / size);
                    const cy = data[1 * 8400 + i] * (canvas.height / size);
                    // Èºª(index 2) = „É©„É≥„Éâ„Éû„Éº„ÇØ„Éá„Éº„ÇøÈñãÂßã(5) + 2*2
                    const nx = data[(5 + 2*2) * 8400 + i] * (canvas.width / size);
                    const ny = data[(5 + 2*2 + 1) * 8400 + i] * (canvas.height / size);
                    boxes.push({ x1: cx - w/2, y1: cy - h/2, w, h, nx: cx/canvas.width, score, noseX: nx, noseY: ny });
                }
            }
            return boxes.sort((a,b) => b.score - a.score).slice(0, 5);
        }

        function finalizeTracks() {
            let tracks = [[], []];
            frameSequence.forEach((frame) => {
                let assigned = [null, null];
                frame.faces.forEach(face => {
                    const id = face.px < canvas.width * 0.5 ? 0 : 1;
                    if (!assigned[id] || face.pScale > assigned[id].pScale) assigned[id] = face;
                });
                tracks[0].push(assigned[0]); tracks[1].push(assigned[1]);
            });
            tracks.forEach(t => { 
                for (let i = 1; i < t.length - 1; i++) {
                    if (!t[i]) {
                        let p = i - 1; while(p >= 0 && !t[p]) p--;
                        let n = i + 1; while(n < t.length && !t[n]) n++;
                        if (p >= 0 && n < t.length && (n - p) < 450) {
                            t[i] = lerpPro(t[p], t[n], (i - p) / (n - p));
                        }
                    }
                }
                smoothPro(t);
            });
            frameSequence.forEach((f, i) => f.faces = [tracks[0][i], tracks[1][i]]);
        }

        function extractMetrics(lm) {
            const nx = (lm[4].x + lm[1].x + lm[195].x)/3, ny = (lm[4].y + lm[1].y + lm[195].y)/3;
            return { nx, ny, scale: Math.abs(lm[454].x - lm[234].x), angle: Math.atan2((lm[263].y - lm[33].y), (lm[263].x - lm[33].x)), yaw: (lm[4].x - (lm[33].x + lm[263].x)*0.5) / (Math.abs(lm[454].x - lm[234].x)*0.5 || 1), pitch: Math.atan2(lm[152].z - lm[4].z, lm[152].y - lm[4].y) };
        }
        function lerpPro(a, b, t) {
            let d = b.angle - a.angle; while(d > Math.PI) d -= Math.PI*2; while(d < -Math.PI) d += Math.PI*2;
            return { px: a.px+(b.px-a.px)*t, py: a.py+(b.py-a.py)*t, pScale: a.pScale+(b.pScale-a.pScale)*t, angle: a.angle+d*t, yaw: a.yaw+(b.yaw-a.yaw)*t, pitch: a.pitch+(b.pitch-a.pitch)*t, isGhost: true };
        }
        function smoothPro(t) {
            const win = 3, copy = JSON.parse(JSON.stringify(t));
            for(let i=0; i<t.length; i++) {
                if(!copy[i]) continue;
                let count=0, sums={px:0,py:0,pScale:0,angle:0,yaw:0,pitch:0};
                for(let j=i-win; j<=i+win; j++){
                    if(copy[j]){ sums.px+=copy[j].px; sums.py+=copy[j].py; sums.pScale+=copy[j].pScale; sums.yaw+=copy[j].yaw; sums.pitch+=copy[j].pitch;
                    let d = copy[j].angle-copy[i].angle; while(d > Math.PI) d -= Math.PI*2; while(d < -Math.PI) d += Math.PI*2;
                    sums.angle += copy[i].angle+d; count++; }
                }
                t[i].px=sums.px/count; t[i].py=sums.py/count; t[i].pScale=sums.pScale/count;
            }
        }

        function renderLoop() {
            if (video.paused || video.ended) return;
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const frame = frameSequence.find(f => f.time >= video.currentTime) || frameSequence[frameSequence.length-1];
            if (frame) frame.faces.forEach(face => { if (face) drawFinalMuzzle(face); });
            requestAnimationFrame(renderLoop);
        }

        function drawFinalMuzzle(f) {
            const px = f.px, py = f.py;
            const yaw = Math.max(-1.2, Math.min(1.2, f.yaw));
            const sxL = 1 - Math.max(0, -yaw)*0.55, sxR = 1 - Math.max(0, yaw)*0.55;
            const baseSizePx = f.pScale * 0.9, dw = baseSizePx, dh = dw / (muzzleImg.width/muzzleImg.height);
            const pitchShift = (f.pitch - 0.5) * baseSizePx * 0.25;

            ctx.save();
            ctx.translate(px + yaw*dw*0.12, py); ctx.rotate(f.angle || 0);
            ctx.globalAlpha = f.isGhost ? 0.6 : 1.0;
            const imgW = muzzleImg.width, imgH = muzzleImg.height;
            ctx.save(); ctx.scale(sxL, 1-Math.abs(yaw)*0.15);
            ctx.drawImage(muzzleImg, 0, 0, imgW/2, imgH, -dw/2, -dh/2 + (dh * 0.12) + pitchShift, dw/2, dh);
            ctx.restore();
            ctx.save(); ctx.scale(sxR, 1-Math.abs(yaw)*0.15);
            ctx.drawImage(muzzleImg, imgW/2, 0, imgW/2, imgH, 0, -dh/2 + (dh * 0.12) + pitchShift, dw/2, dh);
            ctx.restore(); ctx.restore();
        }

        init();
    </script>
</body>
</html>