<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cat Muzzle AI - Professional Studio v142</title>
    <style>
        body { font-family: -apple-system, sans-serif; background: #0a0a0a; color: #eee; text-align: center; margin: 0; padding: 10px; overflow-x: hidden; }
        .card { background: #1a1a1a; padding: 25px; border-radius: 24px; max-width: 850px; margin: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.5); border: 1px solid #333; }
        #log { background: #000; color: #00ff66; font-family: monospace; font-size: 10px; padding: 10px; height: 100px; overflow-y: auto; text-align: left; border-radius: 10px; margin-bottom: 20px; white-space: pre-wrap; border: 1px solid #222; }
        .preview-box { position: relative; width: 100%; background: #000; border-radius: 16px; border: 1px solid #333; overflow: hidden; display: flex; flex-direction: column; align-items: center; min-height: 300px; }
        canvas { width: 100%; height: auto; display: block; image-rendering: -webkit-optimize-contrast; }
        .btn { padding: 16px 32px; background: #6200ee; color: white; border: none; border-radius: 12px; font-weight: bold; cursor: pointer; font-size: 16px; width: 85%; margin: 10px 0; -webkit-tap-highlight-color: transparent; }
        .btn:active { transform: scale(0.98); }
        .btn:disabled { background: #333; color: #777; cursor: wait; }
        .progress-box { width: 90%; margin: 15px auto; display: none; }
        .progress-bar { width: 100%; background: #333; height: 10px; border-radius: 5px; overflow: hidden; }
        #progressFill { width: 0%; background: #00e676; height: 100%; transition: width 0.2s; }
        #progressLabel { font-size:13px; margin-top:8px; color:#00e676; font-weight:bold; }
        #downloadBtn { background: #00c853; display: none; }
        #replayBtn { background: #007bff; display: none; }
    </style>
</head>
<body>
    <div class="card">
        <h2 style="margin-top:0;">üê± CAT MUZZLE STUDIO <span style="font-size:12px; color:#7c4dff;">v142 FINAL</span></h2>
        <div id="log">„É≠„Ç∞: „Ç∑„Çπ„ÉÜ„É†Ëµ∑Âãï‰∏≠...</div>
        
        <input type="file" id="fileInput" accept="image/*,video/*" hidden>
        <button id="uploadBtn" class="btn" disabled>„Ç®„É≥„Ç∏„É≥„Çí„É≠„Éº„Éâ‰∏≠...</button>

        <div class="progress-box" id="progressBox">
            <div class="progress-bar"><div id="progressFill"></div></div>
            <div id="progressLabel">Ê∫ñÂÇô‰∏≠...</div>
        </div>

        <div class="preview-box">
            <canvas id="canvas"></canvas>
            <video id="video" playsinline muted style="display:none;"></video>
        </div>

        <button id="replayBtn" class="btn">üîÑ „ÇÇ„ÅÜ‰∏ÄÂ∫¶ÂÜçÁîü</button>
        <button id="downloadBtn" class="btn">üì• „Éì„Éá„Ç™„Çí‰øùÂ≠òÔºà„Ç´„É°„É©„É≠„Éº„É´Ôºâ</button>
    </div>

    <script type="module">
        import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('video');
        const fileInput = document.getElementById('fileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const replayBtn = document.getElementById('replayBtn');
        const progressBox = document.getElementById('progressBox');
        const progressFill = document.getElementById('progressFill');
        const progressLabel = document.getElementById('progressLabel');
        const logArea = document.getElementById('log');

        let faceLandmarker, muzzleImg = new Image(); muzzleImg.src = "muzzle.png"; 
        let frameData = [], isLooping = false, isExporting = false, audioCtx, audioSource, audioDest;
        const SCAN_FPS = 12;

        function addLog(msg) { logArea.innerText += `> ${msg}\n`; logArea.scrollTop = logArea.scrollHeight; }

        async function init() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `./models/face_landmarker.task`, delegate: "GPU" },
                    runningMode: "IMAGE", numFaces: 2, minFaceDetectionConfidence: 0.1
                });
                addLog("„Ç∑„Çπ„ÉÜ„É†Ê∫ñÂÇôÂÆå‰∫Ü„ÄÇv124„É≠„Ç∏„ÉÉ„ÇØ„ÇíÂæ©ÂÖÉ„Åó„Åæ„Åó„Åü„ÄÇ");
                uploadBtn.disabled = false; uploadBtn.innerText = "ÂãïÁîª„ÇíÈÅ∏Êäû„Åó„Å¶ÈñãÂßã";
                uploadBtn.onclick = () => fileInput.click();
            } catch (e) { addLog("ÂàùÊúüÂåñÂ§±Êïó: " + e.message); }
        }

        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            downloadBtn.style.display = "none"; replayBtn.style.display = "none";
            startV124Analysis(URL.createObjectURL(file));
        };

        // --- 1. v124 Á≤æÂ∫¶Âæ©Ê¥ªÔºö„Éô„Çπ„Éà„Ç∑„Éß„ÉÉ„ÉàÊ§úÁ¥¢ Ôºã 15ÁßíÁîüÂ≠ò„Çπ„Ç≠„É£„É≥ ---
        async function startV124Analysis(url) {
            addLog("ÊâãÈ†Ü1: „Éô„Çπ„Éà„Ç∑„Éß„ÉÉ„Éà„ÇíËá™ÂãïÊé¢Á¥¢‰∏≠...");
            video.src = url; video.load();
            video.onloadedmetadata = async () => {
                canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                frameData = []; progressBox.style.display = "block";
                
                let bestScore = -1;
                let goldenAnchors = [null, null];
                for (let t = 0; t < video.duration; t += 1.0) {
                    video.currentTime = t;
                    await waitSeek(800);
                    const res = faceLandmarker.detect(video);
                    if (res.faceLandmarks && res.faceLandmarks.length >= 1) {
                        let score = res.faceLandmarks.length * 100;
                        res.faceLandmarks.forEach(lm => score += Math.abs(lm[454].x - lm[234].x) * 50);
                        if (score > bestScore) {
                            bestScore = score;
                            const sorted = [...res.faceLandmarks].sort((a,b) => a[4].x - b[4].x);
                            goldenAnchors = sorted.map(lm => ({ x: lm[4].x, y: lm[4].y }));
                        }
                    }
                    progressFill.style.width = Math.floor((t / video.duration) * 100) + "%";
                }
                if (!goldenAnchors[0]) goldenAnchors = [{x:0.3, y:0.5}, {x:0.7, y:0.5}];

                addLog("ÊâãÈ†Ü2: Êú¨Ëß£Êûê‰∏≠Ôºà15ÁßíË£úÈñì„É¢„Éº„ÉâÔºâ...");
                const zCanvas = document.createElement('canvas'); zCanvas.width = 640; zCanvas.height = 640;
                const zCtx = zCanvas.getContext('2d');
                const totalSteps = Math.floor(video.duration * SCAN_FPS);

                for (let i = 0; i <= totalSteps; i++) {
                    const ts = i / SCAN_FPS;
                    video.currentTime = ts;
                    const seekOk = await waitSeek(1000);
                    await new Promise(r => requestAnimationFrame(r));

                    let foundInFrame = [];
                    if (seekOk) {
                        try {
                            for (let id = 0; id < 2; id++) {
                                const anchor = goldenAnchors[id];
                                const rw = canvas.width * 0.45, rh = canvas.height * 0.55;
                                const rx = Math.max(0, Math.min(canvas.width - rw, anchor.x * canvas.width - rw/2));
                                const ry = Math.max(0, Math.min(canvas.height - rh, anchor.y * canvas.height - rh/2));
                                zCtx.clearRect(0,0,640,640);
                                zCtx.filter = "brightness(1.3) contrast(1.6)";
                                zCtx.drawImage(video, rx, ry, rw, rh, 0, 0, 640, 640);
                                const results = faceLandmarker.detect(zCanvas);
                                if (results.faceLandmarks && results.faceLandmarks[0]) {
                                    let metrics = extractMetrics(results.faceLandmarks[0]);
                                    foundInFrame.push({ px: rx + (metrics.nx_local * rw), py: ry + (metrics.ny_local * rh), pScale: metrics.s_local * rw, angle: metrics.angle, yaw: metrics.yaw, pitch: metrics.pitch, lane: id });
                                }
                            }
                        } catch(e) {}
                    }
                    frameData.push({ time: ts, faces: foundInFrame });
                    const percent = Math.floor((i / totalSteps) * 100);
                    progressFill.style.width = percent + "%";
                    progressLabel.innerText = `Ëß£Êûê‰∏≠: ${percent}%`;
                    if (i % 5 === 0) await new Promise(r => setTimeout(r, 1));
                }
                finalizeV124Tracks();
                addLog("ÂÖ®Ëß£Êûê„ÉªË£úÈñìÂÆå‰∫Ü„ÄÇ");
                progressBox.style.display = "none"; downloadBtn.style.display = "block";
                startPlayback();
            };
        }

        async function waitSeek(ms) {
            return new Promise(res => {
                const t = setTimeout(() => res(video.readyState >= 2), ms);
                video.onseeked = () => { clearTimeout(t); res(true); };
            });
        }

        function extractMetrics(lm) {
            // v124/v117 Ê∫ñÊã†ÔºöÈºªÔºã‰∫∫‰∏≠Ôºã‰∏äÂîá„ÅÆÈáç„Åø‰ªò„Åç„Ç¢„É≥„Ç´„Éº
            const nx = lm[4].x * 0.55 + lm[1].x * 0.30 + lm[195].x * 0.15;
            const ny = lm[4].y * 0.45 + lm[1].y * 0.40 + lm[195].y * 0.15;
            const w = Math.abs(lm[454].x - lm[234].x);
            const pitch = (Math.abs(lm[13].y - lm[4].y) / (Math.abs(lm[10].y - lm[152].y) || 0.1) - 0.32) * 2.2;
            return { nx_local: nx, ny_local: ny, s_local: w, pitch, angle: Math.atan2((lm[263].y-lm[33].y),(lm[263].x-lm[33].x)), yaw: (lm[4].x - (lm[33].x+lm[263].x)*0.5)/(w*0.5||1) };
        }

        function finalizeV124Tracks() {
            let tracks = [[], []]; let lastData = [null, null];
            frameData.forEach((frame, idx) => {
                let assigned = [null, null];
                frame.faces.forEach(f => { if (!assigned[f.lane]) assigned[f.lane] = f; });
                for(let id=0; id<2; id++) {
                    let f = assigned[id]; let prev = lastData[id];
                    if (f && prev) {
                        f.yaw = prev.yaw + Math.max(-0.08, Math.min(0.08, f.yaw - prev.yaw));
                        f.pitch = prev.pitch + Math.max(-0.08, Math.min(0.08, f.pitch - prev.pitch));
                        let dAng = f.angle - prev.angle;
                        while(dAng > Math.PI) dAng -= Math.PI * 2; while(dAng < -Math.PI) dAng += Math.PI * 2;
                        f.angle = prev.angle + Math.max(-0.12, Math.min(0.12, dAng));
                    }
                    // v124‰ªïÊßòÔºö15ÁßíÈñìÔºà450„Éï„É¨„Éº„É†ÔºâÁîüÂ≠ò
                    if (!f && prev && prev.life > 0) assigned[id] = { ...prev, life: prev.life - 1, isGhost: true };
                    else if (f) { f.life = 450; f.isGhost = false; }
                    tracks[id].push(assigned[id]); if (assigned[id]) lastData[id] = assigned[id];
                }
            });
            // Ë£úÈñì
            tracks.forEach(track => {
                for (let i = 1; i < track.length - 1; i++) {
                    if (!track[i]) {
                        let p = i - 1; while(p >= 0 && !track[p]) p--;
                        let n = i + 1; while(n < track.length && !track[n]) n++;
                        if (track[p] && track[n] && (n - p) < 450) {
                            const r = (i - p) / (n - p);
                            track[i] = { px: track[p].px+(track[n].px-track[p].px)*r, py: track[p].py+(track[n].py-track[p].py)*r, pScale: track[p].pScale+(track[n].pScale-track[p].pScale)*r, angle: track[p].angle, yaw: track[p].yaw, pitch: track[p].pitch, isGhost: true };
                        }
                    }
                }
            });
            frameData.forEach((f, i) => f.optimized = [tracks[0][i], tracks[1][i]]);
        }

        function startPlayback() { video.currentTime = 0; video.play(); isLooping = true; requestAnimationFrame(liveLoop); }
        video.onended = () => { isLooping = false; replayBtn.style.display = "block"; };
        replayBtn.onclick = () => { replayBtn.style.display = "none"; startPlayback(); };

        function liveLoop() {
            if (!isLooping || isExporting) return;
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const frame = frameData.find(f => f.time >= video.currentTime) || frameData[frameData.length-1];
            if (frame && frame.optimized) frame.optimized.forEach(face => { if (face) drawFinalMuzzle(face); });
            requestAnimationFrame(liveLoop);
        }

        function drawFinalMuzzle(f) {
            const px = f.px, py = f.py;
            const aspect = muzzleImg.width / muzzleImg.height;
            const yaw = Math.max(-1.2, Math.min(1.2, f.yaw));
            const dw = f.pScale * 0.95, dh = dw / aspect;
            const upBias = Math.max(0, f.pitch) * dw * 0.18;
            const yawAbs = Math.abs(yaw);
            const sxL = 1 - Math.max(0, -yaw) * (0.45 + yawAbs * 0.25), sxR = 1 - Math.max(0,  yaw) * (0.45 + yawAbs * 0.25);
            const scaleY = (1 - Math.abs(yaw) * 0.15) * (1.0 + (f.pitch - 0.5) * 0.35);

            ctx.save();
            ctx.translate(px + yaw * dw * 0.16, py - upBias); ctx.rotate(f.angle);
            ctx.globalAlpha = 1.0; 
            const imgW=muzzleImg.width, imgH=muzzleImg.height;
            ctx.save(); ctx.scale(sxL, scaleY); ctx.drawImage(muzzleImg, 0,0,imgW/2,imgH, -dw/2,-dh/2+(dh*0.1), dw/2,dh); ctx.restore();
            ctx.save(); ctx.scale(sxR, scaleY); ctx.drawImage(muzzleImg, imgW/2,0,imgW/2,imgH, 0,-dh/2+(dh*0.1), dw/2,dh); ctx.restore();
            ctx.restore();
        }

        // --- 2. ÊúÄÊñ∞„ÅÆiOS/„Çπ„Éû„ÉõÂØæÂøú‰øùÂ≠ò„É≠„Ç∏„ÉÉ„ÇØ (Web Share API) ---
        downloadBtn.onclick = async () => {
            addLog("‰øùÂ≠ò„Éó„É≠„Çª„Çπ„ÇíÈñãÂßã... ÂãïÁîª„ÅÆÁµÇ‰∫Ü„Åæ„Åß„Åù„ÅÆ„Åæ„Åæ„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ");
            downloadBtn.disabled = true; isExporting = true; isLooping = false;
            video.pause(); progressBox.style.display = "block";

            try {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    audioDest = audioCtx.createMediaStreamDestination();
                    audioSource = audioCtx.createMediaElementSource(video);
                    audioSource.connect(audioDest); audioSource.connect(audioCtx.destination);
                }
                await audioCtx.resume();

                const videoStream = canvas.captureStream(30);
                const combinedStream = new MediaStream([...videoStream.getVideoTracks(), ...audioDest.stream.getAudioTracks()]);
                
                let mimeType = 'video/mp4'; 
                if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'video/webm;codecs=vp9';

                const recorder = new MediaRecorder(combinedStream, { mimeType, videoBitsPerSecond: 12000000 });
                const localChunks = [];
                recorder.ondataavailable = e => { if(e.data.size > 0) localChunks.push(e.data); };
                
                recorder.onstop = async () => {
                    addLog("„Éì„Éá„Ç™„Éï„Ç°„Ç§„É´„ÇíÁîüÊàê‰∏≠...");
                    await new Promise(r => setTimeout(r, 2000));
                    const blob = new Blob(localChunks, { type: mimeType });
                    const file = new File([blob], "cat_muzzle_video.mp4", { type: "video/mp4" });
                    
                    if (navigator.share && navigator.canShare({ files: [file] })) {
                        try {
                            await navigator.share({
                                files: [file],
                                title: 'Cat Muzzle Video',
                                text: '„Ç´„É°„É©„É≠„Éº„É´„Å´‰øùÂ≠ò„Åó„Å¶„Åè„Å†„Åï„ÅÑ'
                            });
                            addLog("ÂÆå‰∫ÜÔºÅÂÖ±Êúâ„É°„Éã„É•„Éº„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
                        } catch(err) { addLog("‰øùÂ≠ò„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„Åü„ÄÇ"); }
                    } else {
                        const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
                        a.download = "result.mp4"; document.body.appendChild(a); a.click(); document.body.removeChild(a);
                    }
                    downloadBtn.disabled = false; isExporting = false; progressBox.style.display = "none"; video.muted = true;
                };

                addLog("Á≠âÂÄçÈÄü„ÅßÈå≤Áîª‰∏≠... Èü≥Â£∞„ÇÇË®òÈå≤„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ");
                video.currentTime = 0; video.muted = false;
                await waitSeek(2000);
                recorder.start(); video.play();

                const exportUpdate = () => {
                    if (!isExporting) return;
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    const frame = frameData.find(f => f.time >= video.currentTime) || frameData[frameData.length-1];
                    if (frame && frame.optimized) frame.optimized.forEach(face => { if (face) drawFinalMuzzle(face); });
                    const percent = Math.floor((video.currentTime / video.duration) * 100);
                    progressFill.style.width = percent + "%";
                    progressLabel.innerText = `Êõ∏„ÅçÂá∫„Åó‰∏≠: ${percent}%`;
                    if (video.ended) setTimeout(() => recorder.stop(), 1000);
                    else requestAnimationFrame(exportUpdate);
                };
                exportUpdate();
            } catch (err) { addLog("„Ç®„É©„Éº: " + err.message); downloadBtn.disabled = false; isExporting = false; }
        };

        init();
    </script>
</body>
</html>