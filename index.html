<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Hybrid Muzzle AI - Fixed 404</title>
    <style>
        body { font-family: sans-serif; background: #1a1a1a; color: #fff; text-align: center; margin: 0; padding: 20px; }
        .card { background: #2d2d2d; padding: 20px; border-radius: 20px; max-width: 700px; margin: auto; }
        #log { background: #000; color: #0f0; font-family: monospace; font-size: 11px; padding: 10px; height: 100px; overflow-y: auto; text-align: left; border-radius: 8px; margin: 10px 0; white-space: pre-wrap; }
        .preview-box { position: relative; border: 2px solid #444; border-radius: 12px; overflow: hidden; background: #000; min-height: 300px; }
        canvas { max-width: 100%; height: auto; display: block; margin: auto; }
        .btn { padding: 16px 32px; background: #7c4dff; color: white; border: none; border-radius: 10px; font-weight: bold; cursor: pointer; margin: 10px; width: 80%; }
        .btn:disabled { background: #444; opacity: 0.6; cursor: wait; }
    </style>
</head>
<body>
    <div class="card">
        <h2>ğŸ± HYBRID MUZZLE AI (Ver. 2.5)</h2>
        <div id="log">ãƒ­ã‚°: ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ä¸­...</div>
        
        <input type="file" id="fileInput" accept="image/*,video/*" hidden>
        <button id="uploadBtn" class="btn" disabled>ã‚¨ãƒ³ã‚¸ãƒ³èª­ã¿è¾¼ã¿ä¸­...</button>

        <div class="preview-box">
            <canvas id="canvas"></canvas>
            <video id="video" playsinline muted style="display:none;"></video>
        </div>
    </div>

    <script type="module">
        import { FaceDetector, FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('video');
        const fileInput = document.getElementById('fileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const logArea = document.getElementById('log');

        let detector;    // è¦‹ã¤ã‘ã‚‹å½¹ (YOLOã‚¹ã‚¿ã‚¤ãƒ«)
        let landmarker;  // æ¸¬ã‚‹å½¹ (ç²¾å¯†è§£æ)
        let muzzleImg = new Image();
        muzzleImg.src = "muzzle.png"; 

        function addLog(msg) {
            logArea.innerText += `> ${msg}\n`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        async function init() {
            try {
                addLog("WASMã‚¨ãƒ³ã‚¸ãƒ³ã‚’èª­ã¿è¾¼ã¿ä¸­...");
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                
                // 1. é¡”æ¤œå‡º (YOLOå½¹) - ãƒ¢ãƒ‡ãƒ«URLã‚’ä¿®æ­£
                addLog("1/2: BlazeFaceãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ä¸­...");
                detector = await FaceDetector.createFromOptions(vision, {
                    baseOptions: { 
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_detector/blaze_face_short_range/float16/1/blaze_face_short_range.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO"
                });

                // 2. ç²¾å¯†ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ (è§£æå½¹)
                addLog("2/2: ç²¾å¯†è§£æãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ä¸­...");
                landmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: { 
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "IMAGE", // åˆ‡ã‚Šå‡ºã—ç”»åƒã«ä½¿ã†ãŸã‚IMAGEãƒ¢ãƒ¼ãƒ‰
                    numFaces: 1
                });

                addLog("ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ã‚¨ãƒ³ã‚¸ãƒ³æº–å‚™å®Œäº†ï¼");
                uploadBtn.disabled = false;
                uploadBtn.innerText = "å†™çœŸãƒ»å‹•ç”»ã‚’é¸æŠ";
                uploadBtn.onclick = () => fileInput.click();
            } catch (e) { 
                addLog("è‡´å‘½çš„ã‚¨ãƒ©ãƒ¼: " + e.message); 
                console.error(e);
            }
        }

        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            if (file.type.startsWith('image/')) {
                const img = new Image();
                img.onload = () => {
                    canvas.width = img.width; canvas.height = img.height;
                    processFrame(img);
                };
                img.src = url;
            } else {
                video.src = url;
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    video.play();
                    loop();
                };
            }
        };

        async function loop() {
            if (video.paused || video.ended) return;
            await processFrame(video);
            requestAnimationFrame(loop);
        }

        // ROIè§£æç”¨ã®ä½¿ã„å›ã—ã‚­ãƒ£ãƒ³ãƒã‚¹
        const roiCanvas = document.createElement('canvas');
        const roiCtx = roiCanvas.getContext('2d');

        async function processFrame(source) {
            // èƒŒæ™¯ã‚’æç”»
            ctx.drawImage(source, 0, 0, canvas.width, canvas.height);

            // 1. Detectorã§è¦‹ã¤ã‘ã‚‹
            const detectionResult = await detector.detectForVideo(source, performance.now());
            
            if (detectionResult.detections) {
                for (const detection of detectionResult.detections) {
                    const bbox = detection.boundingBox;

                    // 2. ROIåˆ‡ã‚Šå‡ºã— (å‘¨è¾ºæƒ…å ±ã‚’å…¥ã‚Œã‚‹ãŸã‚30%ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°)
                    const pad = 0.3;
                    const roi = {
                        x: Math.max(0, bbox.originX - bbox.width * pad),
                        y: Math.max(0, bbox.originY - bbox.height * pad),
                        w: Math.min(canvas.width - bbox.originX, bbox.width * (1 + pad * 2)),
                        h: Math.min(canvas.height - bbox.originY, bbox.height * (1 + pad * 2))
                    };

                    roiCanvas.width = roi.w; roiCanvas.height = roi.h;
                    roiCtx.drawImage(canvas, roi.x, roi.y, roi.w, roi.h, 0, 0, roi.w, roi.h);

                    // 3. åˆ‡ã‚Šå‡ºã—ãŸROIã«å¯¾ã—ã¦ç²¾å¯†è§£æ (IMAGEãƒ¢ãƒ¼ãƒ‰ã§å®Ÿè¡Œ)
                    const landmarkResult = await landmarker.detect(roiCanvas);

                    if (landmarkResult.faceLandmarks && landmarkResult.faceLandmarks.length > 0) {
                        drawPreciseMuzzle(landmarkResult.faceLandmarks[0], roi);
                    }
                }
            }
        }

        function drawPreciseMuzzle(landmarks, roi) {
            // ROIå†…ã®ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ã‚’å…¨ä½“åº§æ¨™ã¸å¤‰æ›
            const toGlobal = (lm) => ({
                x: roi.x + (lm.x * roi.w),
                y: roi.y + (lm.y * roi.h),
                z: lm.z * roi.w // Zã‚‚ã‚¹ã‚±ãƒ¼ãƒ«ã¨ã—ã¦å¤‰æ›
            });

            const noseTip = toGlobal(landmarks[4]);
            const jawL = toGlobal(landmarks[234]);
            const jawR = toGlobal(landmarks[454]);
            const eyeL = toGlobal(landmarks[33]);
            const eyeR = toGlobal(landmarks[263]);

            const faceCenterX = (jawL.x + jawR.x) / 2;
            const faceWidth2D = Math.abs(jawR.x - jawL.x);
            const yawFactor = (noseTip.x - faceCenterX) / (faceWidth2D / 2);

            const faceWidth3D = Math.hypot(jawR.x - jawL.x, (jawR.z - jawL.z));
            const angle = Math.atan2(eyeR.y - eyeL.y, eyeR.x - eyeL.x);

            // ã€æ¨ªé¡”ã‚«ãƒãƒ¼ãƒ­ã‚¸ãƒƒã‚¯ã€‘
            const expansion = 1.0 + Math.abs(yawFactor) * 0.5; // æ¨ªå‘ãæ™‚ã«ã•ã‚‰ã«æ‹¡å¤§
            const baseSize = faceWidth3D * 0.85 * expansion;
            const squeezeFactor = Math.max(0.5, Math.cos(yawFactor * (Math.PI / 2.2)));
            const targetWidth = baseSize * squeezeFactor;
            const targetHeight = targetWidth / (muzzleImg.width / muzzleImg.height);

            // ã€æ‰‹å‰å°é¼»éš ã—ã€‘å¥¥å´ã®å›ã‚Šè¾¼ã¿(0.35) + æ‰‹å‰ã¸ã®çªãå‡ºã—(0.30)
            const totalXOffset = yawFactor * baseSize * 0.65; 

            ctx.save();
            ctx.translate(noseTip.x, noseTip.y);
            ctx.rotate(angle);
            ctx.drawImage(
                muzzleImg, 
                -targetWidth / 2 + totalXOffset, 
                -targetHeight / 2 + (targetHeight * 0.18), 
                targetWidth, 
                targetHeight
            );
            ctx.restore();
        }

        init();
    </script>
</body>
</html>