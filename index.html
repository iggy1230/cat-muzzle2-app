<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Cat Muzzle AI - Professional v31 Final</title>
    <style>
        body { font-family: 'Helvetica Neue', Arial, sans-serif; background: #0a0a0a; color: #eee; text-align: center; margin: 0; padding: 20px; }
        .card { background: #1a1a1a; padding: 25px; border-radius: 24px; max-width: 850px; margin: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.8); border: 1px solid #333; }
        #log { background: #000; color: #00ff66; font-family: 'Consolas', monospace; font-size: 11px; padding: 12px; height: 100px; overflow-y: auto; text-align: left; border-radius: 12px; margin-bottom: 20px; border: 1px solid #222; white-space: pre-wrap; }
        .preview-box { position: relative; width: 100%; background: #000; border-radius: 16px; border: 1px solid #333; overflow: hidden; display: flex; flex-direction: column; align-items: center; }
        canvas { width: 100%; height: auto; display: block; background: #000; }
        .btn { padding: 18px 36px; background: #6200ee; color: white; border: none; border-radius: 14px; font-weight: bold; cursor: pointer; font-size: 16px; width: 90%; margin: 8px 0; transition: all 0.3s; }
        .btn:hover:not(:disabled) { background: #7c4dff; transform: translateY(-2px); }
        .btn:disabled { background: #333; color: #777; cursor: wait; }
        .btn-save { background: #00c853; display: none; }
        .progress-box { width: 90%; margin: 15px auto; display: none; }
        .progress-bar { width: 100%; background: #444; height: 12px; border-radius: 6px; overflow: hidden; }
        #progressFill { width: 0%; background: linear-gradient(90deg, #00e676, #00c853); height: 100%; transition: width 0.2s; }
        #progressLabel { font-size:14px; margin-top:8px; color:#00e676; font-weight:bold; }
    </style>
</head>
<body>
    <div class="card">
        <h2 style="margin-top:0;">üê± CAT MUZZLE AI <span style="font-size:12px; color:#7c4dff;">v31 PRO STUDIO</span></h2>
        <div id="log">„É≠„Ç∞: „Ç∑„Çπ„ÉÜ„É†Ëµ∑Âãï‰∏≠...</div>
        
        <input type="file" id="fileInput" accept="image/*,video/*" hidden>
        <button id="uploadBtn" class="btn" disabled>AI„Ç®„É≥„Ç∏„É≥„Çí„É≠„Éº„Éâ‰∏≠...</button>

        <div class="progress-box" id="progressBox">
            <div class="progress-bar"><div id="progressFill"></div></div>
            <div id="progressLabel">Ê∫ñÂÇô‰∏≠...</div>
        </div>

        <div class="preview-box">
            <canvas id="canvas"></canvas>
            <video id="video" playsinline muted style="display:none;"></video>
        </div>

        <button id="downloadBtn" class="btn btn-save">üì• ÂãïÁîª„ÇíÊõ∏„ÅçÂá∫„Åó„Å¶‰øùÂ≠ò</button>
    </div>

    <script type="module">
        import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('video');
        const fileInput = document.getElementById('fileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const progressBox = document.getElementById('progressBox');
        const progressFill = document.getElementById('progressFill');
        const progressLabel = document.getElementById('progressLabel');
        const logArea = document.getElementById('log');

        let faceLandmarker;
        let muzzleImg = new Image();
        muzzleImg.src = "muzzle.png"; 

        let frameSequence = []; 
        const FPS = 30;

        function addLog(msg) {
            logArea.innerText += `> ${msg}\n`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        async function init() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`, delegate: "GPU" },
                    runningMode: "IMAGE", numFaces: 2
                });
                addLog("„Ç∑„Çπ„ÉÜ„É†Ê∫ñÂÇôÂÆå‰∫Ü„ÄÇ");
                uploadBtn.disabled = false;
                uploadBtn.innerText = "ÂãïÁîª„ÉªÂÜôÁúü„ÇíÈÅ∏Êäû";
                uploadBtn.onclick = () => fileInput.click();
            } catch (e) { addLog("ÂàùÊúüÂåñÂ§±Êïó: " + e.message); }
        }

        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            downloadBtn.style.display = "none";
            if (file.type.startsWith('image/')) processImage(URL.createObjectURL(file));
            else startDeepScan(URL.createObjectURL(file));
        };

        // --- 1. ÂãïÁîª„ÅÆÁ≤æÂØÜ„Çπ„Ç≠„É£„É≥Ôºà„É°„Ç§„É≥Âá¶ÁêÜÔºâ ---
        async function startDeepScan(url) {
            addLog("ÂãïÁîª„ÅÆËß£Êûê„ÇíÈñãÂßã...");
            video.src = url;
            video.load();

            video.onloadedmetadata = async () => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                frameSequence = [];
                progressBox.style.display = "block";
                
                const totalFrames = Math.floor(video.duration * FPS);

                for (let i = 0; i <= totalFrames; i++) {
                    video.currentTime = i / FPS;
                    await new Promise(r => {
                        const timeout = setTimeout(r, 1000); // Âøµ„ÅÆ„Åü„ÇÅ„ÅÆ„Çø„Ç§„É†„Ç¢„Ç¶„Éà
                        video.onseeked = () => { clearTimeout(timeout); r(); };
                    });

                    const results = faceLandmarker.detect(video);
                    frameSequence.push({
                        time: video.currentTime,
                        rawFaces: results.faceLandmarks || []
                    });

                    const percent = Math.floor((i / totalFrames) * 100);
                    progressFill.style.width = percent + "%";
                    progressLabel.innerText = `Ëß£ÊûêÈÄ≤Êçó: ${percent}% (${i}/${totalFrames})`;
                    
                    if (i % 20 === 0) await new Promise(r => setTimeout(r, 1));
                }

                addLog("Ëß£ÊûêÂÆå‰∫Ü„ÄÇ2‰∫∫„ÅÆËªåË∑°„ÇíÊúÄÈÅ©Âåñ‰∏≠...");
                optimizeTracks();
                
                addLog("Ê∫ñÂÇôÂÆå‰∫Ü„ÄÇ");
                progressBox.style.display = "none";
                downloadBtn.style.display = "block";
                
                video.currentTime = 0;
                video.play();
                requestAnimationFrame(liveLoop);
            };
        }

        function liveLoop() {
            if (video.paused || video.ended) return;
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const frame = frameSequence.find(f => f.time >= video.currentTime) || frameSequence[frameSequence.length-1];
            if (frame && frame.faces) {
                frame.faces.forEach(f => { if (f) drawAsymmetricMuzzle(f); });
            }
            requestAnimationFrame(liveLoop);
        }

        // --- 2. Êõ∏„ÅçÂá∫„ÅóÂá¶ÁêÜÔºà„Éï„É™„Éº„Ç∫ÂõûÈÅøÁâàÔºâ ---
        downloadBtn.onclick = async () => {
            addLog("Êõ∏„ÅçÂá∫„Åó„Éó„É≠„Çª„Çπ„ÇíÈñãÂßãÔºà„Éï„É™„Éº„Ç∫ÂõûÈÅø„É¢„Éº„ÉâÔºâ...");
            downloadBtn.disabled = true;
            progressBox.style.display = "block";
            video.pause();

            const chunks = [];
            const stream = canvas.captureStream(0); 
            // Chrome„ÅßÊúÄ„ÇÇÂÆâÂÆö„Åô„ÇãWebMË®≠ÂÆö
            const recorder = new MediaRecorder(stream, { 
                mimeType: 'video/webm;codecs=vp9', 
                videoBitsPerSecond: 8000000 // 8Mbps
            });

            recorder.ondataavailable = (e) => { if (e.data.size > 0) chunks.push(e.data); };
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = "cat_muzzle_pro.webm"; a.click();
                addLog("‰øùÂ≠ò„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„ÅüÔºÅ");
                downloadBtn.disabled = false;
                progressBox.style.display = "none";
            };

            recorder.start();

            // 1„Ç≥„Éû„Åö„Å§‰∏ÅÂØß„Å´ÊèèÁîª„Åó„Å¶„Ç≠„É£„Éó„ÉÅ„É£
            for (let i = 0; i < frameSequence.length; i++) {
                const frame = frameSequence[i];
                video.currentTime = frame.time;
                
                await new Promise(r => {
                    const timeout = setTimeout(r, 1000);
                    video.onseeked = () => { clearTimeout(timeout); r(); };
                });

                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                if (frame.faces) {
                    frame.faces.forEach(f => { if (f) drawAsymmetricMuzzle(f); });
                }

                // „Éï„É¨„Éº„É†„Çí„Éì„Éá„Ç™„Éà„É©„ÉÉ„ÇØ„Å´„Éó„ÉÉ„Ç∑„É•
                stream.getVideoTracks()[0].requestFrame(); 
                
                const percent = Math.floor((i / frameSequence.length) * 100);
                progressFill.style.width = percent + "%";
                progressLabel.innerText = `Êõ∏„ÅçÂá∫„Åó‰∏≠: ${percent}% (${i}/${frameSequence.length})`;
                
                // „ÄêÊúÄÈáçË¶Å„Äë„Éñ„É©„Ç¶„Ç∂„Å´Âà∂Âæ°„ÇíÊàª„Åô„ÄÇ„Åì„Çå„Åå„Å™„ÅÑ„Å®„Éï„É™„Éº„Ç∫„Åô„Çã„ÄÇ
                if (i % 3 === 0) await new Promise(r => setTimeout(r, 15));
            }

            addLog("„Éï„Ç°„Ç§„É´„ÇíÁîüÊàê„Åó„Å¶„ÅÑ„Åæ„Åô...");
            setTimeout(() => recorder.stop(), 1000);
        };

        // --- 3. ÂÖ•„ÇåÊõø„Çè„ÇäÈò≤Ê≠¢„Éà„É©„ÉÉ„Ç≠„É≥„Ç∞ ---
        function optimizeTracks() {
            const tracks = [[], []];
            let lastPos = [null, null];

            frameSequence.forEach((frame, idx) => {
                let currentRaw = frame.rawFaces;
                let assigned = [null, null];

                if (idx > 0) {
                    let available = currentRaw.map((_, i) => i);
                    [0, 1].forEach(id => {
                        if (lastPos[id]) {
                            let bestMatch = -1, minDist = 0.2;
                            available.forEach(fIdx => {
                                const d = Math.hypot(currentRaw[fIdx][4].x - lastPos[id].x, currentRaw[fIdx][4].y - lastPos[id].y);
                                if (d < minDist) { minDist = d; bestMatch = fIdx; }
                            });
                            if (bestMatch !== -1) {
                                assigned[id] = extractMetrics(currentRaw[bestMatch]);
                                available = available.filter(i => i !== bestMatch);
                            }
                        }
                    });
                    available.forEach(fIdx => {
                        if (!assigned[0]) assigned[0] = extractMetrics(currentRaw[fIdx]);
                        else if (!assigned[1]) assigned[1] = extractMetrics(currentRaw[fIdx]);
                    });
                } else {
                    currentRaw.sort((a,b) => a[4].x - b[4].x);
                    assigned[0] = currentRaw[0] ? extractMetrics(currentRaw[0]) : null;
                    assigned[1] = currentRaw[1] ? extractMetrics(currentRaw[1]) : null;
                }
                
                for(let id=0; id<2; id++) {
                    tracks[id].push(assigned[id]);
                    if (assigned[id]) lastPos[id] = { x: assigned[id].nx, y: assigned[id].ny };
                }
            });

            // „ÄêÂÖ•„ÇåÊõø„Çè„ÇäÈò≤Ê≠¢„ÄëÂÖ®ÊúüÈñì„ÅÆÂπ≥Âùá‰ΩçÁΩÆ„ÅßÂ∑¶Âè≥„Çí„ÇΩ„Éº„Éà
            const avgX0 = getAvgX(tracks[0]);
            const avgX1 = getAvgX(tracks[1]);
            if (avgX1 !== 0 && avgX0 > avgX1) tracks.reverse();

            // Ë£úÈñì„Å®Âπ≥ÊªëÂåñ
            tracks.forEach(t => { 
                for (let i = 1; i < t.length - 1; i++) {
                    if (!t[i]) {
                        let p = i - 1; while(p >= 0 && !t[p]) p--;
                        let n = i + 1; while(n < t.length && !t[n]) n++;
                        if (p >= 0 && n < t.length) {
                            const r = (i - p) / (n - p); t[i] = {};
                            ['nx', 'ny', 'scale', 'yaw', 'pitch', 'roll'].forEach(k => {
                                if (['roll', 'yaw', 'pitch'].includes(k)) {
                                    let d = t[n][k] - t[p][k];
                                    while(d > Math.PI) d -= Math.PI*2; while(d < -Math.PI) d += Math.PI*2;
                                    t[i][k] = t[p][k] + d * r;
                                } else { t[i][k] = t[p][k] + (t[n][k] - t[p][k]) * r; }
                            });
                        }
                    }
                }
                // 7„Éï„É¨„Éº„É†Âπ≥Âùá
                const win = 3, copy = JSON.parse(JSON.stringify(t));
                for (let i = 0; i < t.length; i++) {
                    if (!copy[i]) continue;
                    let count = 0, sums = {nx:0, ny:0, scale:0, roll:0, yaw:0, pitch:0};
                    for (let j = i-win; j <= i+win; j++) {
                        if (copy[j]) {
                            sums.nx += copy[j].nx; sums.ny += copy[j].ny; sums.scale += copy[j].scale;
                            ['roll', 'yaw', 'pitch'].forEach(k => {
                                let d = copy[j][k] - copy[i][k];
                                while(d > Math.PI) d -= Math.PI*2; while(d < -Math.PI) d += Math.PI*2;
                                sums[k] += copy[i][k] + d;
                            });
                            count++;
                        }
                    }
                    t[i] = { ...copy[i], nx:sums.nx/count, ny:sums.ny/count, scale:sums.scale/count, roll:sums.roll/count, yaw:sums.yaw/count, pitch:sums.pitch/count };
                }
            });

            frameSequence.forEach((f, i) => f.faces = [tracks[0][i], tracks[1][i]]);
        }

        // --- 4. ÈùûÂØæÁß∞ÊèèÁîª„É≠„Ç∏„ÉÉ„ÇØ ---
        function drawAsymmetricMuzzle(f) {
            const px = f.nx * canvas.width, py = f.ny * canvas.height;
            const yaw = Math.max(-1.2, Math.min(1.2, f.yaw));
            const aspect = muzzleImg.width / muzzleImg.height;
            const sxL = 1 - Math.max(0, -yaw) * 0.45, sxR = 1 - Math.max(0, yaw) * 0.45;
            const baseSizePx = f.scale * canvas.width * 0.9;
            const centerShiftX = yaw * baseSizePx * 0.12;
            const scaleY = 1 - Math.abs(yaw) * 0.15;
            const pitchShift = (f.pitch - 0.5) * baseSizePx * 0.25;
            const dw = baseSizePx, dh = baseSizePx / aspect;

            ctx.save();
            ctx.translate(px + centerShiftX, py); ctx.rotate(f.roll);
            ctx.globalAlpha = Math.max(0, Math.min(1.0, 1.8 - Math.abs(yaw)));
            const imgW = muzzleImg.width, imgH = muzzleImg.height;
            ctx.save(); ctx.scale(sxL, scaleY);
            ctx.drawImage(muzzleImg, 0, 0, imgW/2, imgH, -dw/2, -dh/2 + (dh*0.15) + pitchShift, dw/2, dh);
            ctx.restore();
            ctx.save(); ctx.scale(sxR, scaleY);
            ctx.drawImage(muzzleImg, imgW/2, 0, imgW/2, imgH, 0, -dh/2 + (dh*0.15) + pitchShift, dw/2, dh);
            ctx.restore(); ctx.restore();
        }

        function extractMetrics(lm) {
            const nx = (lm[4].x + lm[1].x + lm[195].x)/3, ny = (lm[4].y + lm[1].y + lm[195].y)/3;
            const eyeL = lm[33], eyeR = lm[263], jawL = lm[234], jawR = lm[454], chin = lm[152];
            const yaw3D = Math.atan2(eyeR.z - eyeL.z, eyeR.x - eyeL.x), yaw2D = (lm[4].x - (eyeL.x + eyeR.x)*0.5) / (Math.abs(jawR.x - jawL.x)*0.5 || 0.1);
            return { nx, ny, yaw: yaw2D*0.6 + yaw3D*0.4, pitch: Math.atan2(chin.z - lm[4].z, chin.y - lm[4].y), scale: Math.abs(jawR.x - jawL.x)*0.4 + Math.abs(lm[323].x - lm[93].x)*0.4 + Math.abs(eyeR.x - eyeL.x)*0.2, roll: Math.atan2((eyeR.y - eyeL.y)*canvas.height, (eyeR.x - eyeL.x)*canvas.width) };
        }
        function getAvgX(t) { let s = 0, c = 0; t.forEach(f => { if(f){ s += f.nx; c++; }}); return c > 0 ? s / c : 0; }

        async function processImage(url) {
            const img = new Image();
            img.onload = () => {
                canvas.width = img.width; canvas.height = img.height;
                const results = faceLandmarker.detect(img);
                ctx.drawImage(img, 0, 0);
                if (results.faceLandmarks) results.faceLandmarks.forEach(lm => drawAsymmetricMuzzle(extractMetrics(lm)));
                downloadBtn.style.display = "block"; downloadBtn.innerText = "üì• ÁîªÂÉè„Çí‰øùÂ≠ò";
                downloadBtn.onclick = () => { const a = document.createElement('a'); a.href = canvas.toDataURL("image/png"); a.download = "result.png"; a.click(); };
            };
            img.src = url;
        }

        init();
    </script>
</body>
</html>