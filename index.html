<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Cat Muzzle AI - Asymmetric Precision v26</title>
    <style>
        body { font-family: sans-serif; background: #050505; color: #eee; text-align: center; margin: 0; padding: 20px; }
        .card { background: #151515; padding: 30px; border-radius: 24px; max-width: 850px; margin: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.8); border: 1px solid #222; }
        #log { background: #000; color: #00ff66; font-family: monospace; font-size: 11px; padding: 12px; height: 100px; overflow-y: auto; text-align: left; border-radius: 12px; margin-bottom: 20px; border: 1px solid #222; white-space: pre-wrap; }
        .preview-box { position: relative; width: 100%; background: #000; border-radius: 16px; border: 1px solid #333; overflow: hidden; display: flex; flex-direction: column; align-items: center; }
        canvas { width: 100%; height: auto; display: block; }
        .btn { padding: 18px 36px; background: #6200ee; color: white; border: none; border-radius: 14px; font-weight: bold; cursor: pointer; font-size: 16px; width: 90%; margin: 10px 0; transition: all 0.3s; }
        .btn:hover:not(:disabled) { background: #7c4dff; transform: translateY(-2px); }
        .btn:disabled { background: #333; color: #777; cursor: wait; }
        .progress-box { width: 90%; margin: 15px auto; display: none; }
        .progress-bar { width: 100%; background: #333; height: 10px; border-radius: 5px; overflow: hidden; }
        #progressFill { width: 0%; background: linear-gradient(90deg, #00e676, #00c853); height: 100%; }
    </style>
</head>
<body>
    <div class="card">
        <h2 style="margin-top:0;">ğŸ± CAT MUZZLE AI <span style="font-size:12px; color:#7c4dff;">v26 ASYMMETRIC-SPLIT</span></h2>
        <div id="log">ãƒ­ã‚°: ã‚·ã‚¹ãƒ†ãƒ èµ·å‹•ä¸­...</div>
        
        <input type="file" id="fileInput" accept="image/*,video/*" hidden>
        <button id="uploadBtn" class="btn" disabled>ã‚¨ãƒ³ã‚¸ãƒ³ã‚’ãƒ­ãƒ¼ãƒ‰ä¸­...</button>

        <div class="progress-box" id="progressBox">
            <div class="progress-bar"><div id="progressFill"></div></div>
            <div id="progressLabel" style="font-size:13px; margin-top:8px; color:#00e676; font-weight:bold;">å‹•ç”»ã®3Dæ§‹é€ ã‚’è©³ç´°è§£æä¸­... 0%</div>
        </div>

        <div class="preview-box">
            <canvas id="canvas"></canvas>
            <video id="video" playsinline muted style="display:none;"></video>
        </div>
    </div>

    <script type="module">
        import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('video');
        const fileInput = document.getElementById('fileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const progressBox = document.getElementById('progressBox');
        const progressFill = document.getElementById('progressFill');
        const progressLabel = document.getElementById('progressLabel');
        const logArea = document.getElementById('log');

        let faceLandmarker;
        let muzzleImg = new Image();
        muzzleImg.src = "muzzle.png"; 

        let frameSequence = []; 

        function addLog(msg) {
            logArea.innerText += `> ${msg}\n`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        async function init() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`, delegate: "GPU" },
                    runningMode: "IMAGE", numFaces: 2
                });
                addLog("ã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†ã€‚");
                uploadBtn.disabled = false;
                uploadBtn.innerText = "å‹•ç”»ãƒ»å†™çœŸã‚’é¸æŠ";
                uploadBtn.onclick = () => fileInput.click();
            } catch (e) { addLog("åˆæœŸåŒ–å¤±æ•—: " + e.message); }
        }

        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            if (file.type.startsWith('image/')) processImage(url);
            else runProAnalysis(url);
        };

        async function runProAnalysis(url) {
            addLog("3Då…¨ãƒ•ãƒ¬ãƒ¼ãƒ è§£æã‚’é–‹å§‹...");
            video.src = url; video.load();
            video.onloadedmetadata = async () => {
                canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                frameSequence = []; progressBox.style.display = "block";
                
                const fps = 30, totalFrames = Math.floor(video.duration * fps);
                let rawTracks = [[], []]; let lastPos = [null, null];

                for (let i = 0; i <= totalFrames; i++) {
                    video.currentTime = i / fps;
                    await new Promise(r => video.onseeked = r);
                    const results = faceLandmarker.detect(video);
                    const faces = results.faceLandmarks || [];
                    
                    let assigned = [null, null];
                    if (faces.length > 0) {
                        let available = faces.map((_, idx) => idx);
                        [0, 1].forEach(id => {
                            if (lastPos[id]) {
                                let best = -1, minDist = 0.2;
                                available.forEach(idx => {
                                    const d = Math.hypot(faces[idx][4].x - lastPos[id].x, faces[idx][4].y - lastPos[id].y);
                                    if (d < minDist) { minDist = d; best = idx; }
                                });
                                if (best !== -1) { assigned[id] = faces[best]; available = available.filter(n => n !== best); }
                            }
                        });
                        available.forEach(idx => { if (!assigned[0]) assigned[0] = faces[idx]; else if (!assigned[1]) assigned[1] = faces[idx]; });
                    }
                    for (let id = 0; id < 2; id++) {
                        const metrics = assigned[id] ? extractMetrics(assigned[id]) : null;
                        rawTracks[id].push(metrics);
                        if (metrics) lastPos[id] = { x: metrics.nx, y: metrics.ny };
                    }
                    progressFill.style.width = (i/totalFrames*100) + "%";
                }

                // ã‚°ãƒ­ãƒ¼ãƒãƒ«IDã‚½ãƒ¼ãƒˆ
                const avgX0 = getAvg(rawTracks[0], 'nx'); const avgX1 = getAvg(rawTracks[1], 'nx');
                if (avgX1 !== 0 && avgX0 > avgX1) [rawTracks[0], rawTracks[1]] = [rawTracks[1], rawTracks[0]];

                rawTracks.forEach(t => { interpolate(t); smooth(t); });
                frameSequence = Array.from({length: rawTracks[0].length}, (_, i) => ({ time: i / fps, faces: [rawTracks[0][i], rawTracks[1][i]] }));

                addLog("è§£æå®Œäº†ã€‚ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’é–‹å§‹ã—ã¾ã™ã€‚");
                progressBox.style.display = "none";
                video.currentTime = 0; video.play();
                requestAnimationFrame(renderLoop);
            };
        }

        function extractMetrics(lm) {
            const nx = (lm[4].x + lm[1].x + lm[195].x) / 3;
            const ny = (lm[4].y + lm[1].y + lm[195].y) / 3;
            const eyeL = lm[33], eyeR = lm[263], jawL = lm[234], jawR = lm[454], chin = lm[152];
            const yaw3D = Math.atan2(eyeR.z - eyeL.z, eyeR.x - eyeL.x); 
            const yaw2D = (lm[4].x - (eyeL.x + eyeR.x)*0.5) / (Math.abs(jawR.x - jawL.x)*0.5 || 0.1);
            const pitch = Math.atan2(chin.z - lm[4].z, chin.y - lm[4].y); 
            const scale = Math.abs(jawR.x - jawL.x)*0.4 + Math.abs(lm[323].x - lm[93].x)*0.4 + Math.abs(eyeR.x - eyeL.x)*0.2;
            return { nx, ny, yaw: yaw2D * 0.6 + yaw3D * 0.4, pitch, scale, 
                     roll: Math.atan2((eyeR.y - eyeL.y) * canvas.height, (eyeR.x - eyeL.x) * canvas.width) };
        }

        function interpolate(track) {
            for (let i = 1; i < track.length - 1; i++) {
                if (!track[i]) {
                    let p = i - 1; while(p >= 0 && !track[p]) p--;
                    let n = i + 1; while(n < track.length && !track[n]) n++;
                    if (p >= 0 && n < track.length) {
                        const r = (i - p) / (n - p); track[i] = {};
                        ['nx', 'ny', 'scale'].forEach(k => track[i][k] = track[p][k] + (track[n][k] - track[p][k]) * r);
                        ['roll', 'yaw', 'pitch'].forEach(k => {
                            let d = track[n][k] - track[p][k];
                            while(d > Math.PI) d -= Math.PI*2; while(d < -Math.PI) d += Math.PI*2;
                            track[i][k] = track[p][k] + d * r;
                        });
                    }
                }
            }
        }

        function smooth(t) {
            const win = 3, copy = JSON.parse(JSON.stringify(t));
            for (let i = 0; i < t.length; i++) {
                if (!copy[i]) continue;
                let count = 0, sums = {nx:0, ny:0, scale:0, roll:0, yaw:0, pitch:0};
                for (let j = i-win; j <= i+win; j++) {
                    if (copy[j]) {
                        sums.nx += copy[j].nx; sums.ny += copy[j].ny; sums.scale += copy[j].scale;
                        ['roll', 'yaw', 'pitch'].forEach(k => {
                            let d = copy[j][k] - copy[i][k];
                            while(d > Math.PI) d -= Math.PI*2; while(d < -Math.PI) d += Math.PI*2;
                            sums[k] += copy[i][k] + d;
                        });
                        count++;
                    }
                }
                for(let k in sums) t[i][k] = sums[k] / count;
            }
        }

        function getAvg(t, k) { let s = 0, c = 0; t.forEach(f => { if(f){ s += f[k]; c++; }}); return c > 0 ? s / c : 0; }

        function renderLoop() {
            if (video.paused || video.ended) return;
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const frame = frameSequence.find(f => f.time >= video.currentTime) || frameSequence[frameSequence.length-1];
            if (frame) frame.faces.forEach(f => { if (f) drawAsymmetricMuzzle(f); });
            requestAnimationFrame(renderLoop);
        }

        // --- 2. éå¯¾ç§°å¤‰å½¢ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° (v25 æ ¸å¿ƒå®Ÿè£…) ---
        function drawAsymmetricMuzzle(f) {
            if (!muzzleImg.complete) return;

            const px = f.nx * canvas.width;
            const py = f.ny * canvas.height;
            const yaw = Math.max(-1.2, Math.min(1.2, f.yaw)); // éå‰°ãªæ­ªã¿ã‚’æŠ‘åˆ¶
            const aspect = muzzleImg.width / muzzleImg.height;

            // â‘  å·¦å³ã‚¹ã‚±ãƒ¼ãƒ«å·®ï¼šä¿®æ­£ç‰ˆ
            // yawãŒãƒ—ãƒ©ã‚¹(é¼»ãŒå³ç§»å‹•) = å³ã‚’å‘ã„ã¦ã„ã‚‹ = å·¦å´ãŒæ‰‹å‰
            // ã‚ˆã£ã¦ sxR(å¥¥å´)ã‚’æ½°ã™
            const sxL = 1 - Math.max(0, -yaw) * 0.45;
            const sxR = 1 - Math.max(0, yaw) * 0.45;

            // â‘¡ ã‚»ãƒ³ã‚¿ãƒ¼ãƒ»ã‚·ãƒ•ãƒˆ
            const baseSizePx = f.scale * canvas.width * 0.9; 
            const centerShiftX = yaw * baseSizePx * 0.12;

            // â‘¢ å‚ç›´ã‚¹ã‚±ãƒ¼ãƒ«ã¨Pitchè£œæ­£
            const scaleY = 1 - Math.abs(yaw) * 0.15;
            const pitchShift = (f.pitch - 0.5) * baseSizePx * 0.25;

            const dw = baseSizePx;
            const dh = baseSizePx / aspect;

            ctx.save();
            ctx.translate(px + centerShiftX, py);
            ctx.rotate(f.roll);
            
            // è§’åº¦ã‚¬ãƒ¼ãƒ‰ï¼šé™ç•Œè§’ã§å°‘ã—é€é
            ctx.globalAlpha = Math.max(0, Math.min(1.0, 1.8 - Math.abs(yaw)));

            const imgW = muzzleImg.width;
            const imgH = muzzleImg.height;

            // å·¦åŠåˆ†
            ctx.save();
            ctx.scale(sxL, scaleY);
            ctx.drawImage(muzzleImg, 0, 0, imgW / 2, imgH, -dw/2, -dh/2 + (dh * 0.15) + pitchShift, dw/2, dh);
            ctx.restore();

            // å³åŠåˆ†
            ctx.save();
            ctx.scale(sxR, scaleY);
            ctx.drawImage(muzzleImg, imgW / 2, 0, imgW / 2, imgH, 0, -dh/2 + (dh * 0.15) + pitchShift, dw/2, dh);
            ctx.restore();

            ctx.restore();
        }

        init();
    </script>
</body>
</html>