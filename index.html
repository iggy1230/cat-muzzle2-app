<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Hybrid Cat Muzzle AI - Fixed Model Path</title>
    <style>
        body { font-family: sans-serif; background: #1a1a1a; color: #fff; text-align: center; margin: 0; padding: 20px; }
        .card { background: #2d2d2d; padding: 20px; border-radius: 20px; max-width: 700px; margin: auto; }
        #log { background: #000; color: #0f0; font-family: monospace; font-size: 11px; padding: 10px; height: 100px; overflow-y: auto; text-align: left; border-radius: 8px; margin: 10px 0; white-space: pre-wrap; }
        .preview-box { position: relative; border: 2px solid #444; border-radius: 12px; overflow: hidden; background: #000; min-height: 300px; }
        canvas { max-width: 100%; height: auto; display: block; margin: auto; }
        .btn { padding: 16px 32px; background: #7c4dff; color: white; border: none; border-radius: 10px; font-weight: bold; cursor: pointer; margin: 10px; width: 80%; }
        .btn:disabled { background: #444; opacity: 0.6; cursor: wait; }
    </style>
</head>
<body>
    <div class="card">
        <h2>ğŸ± HYBRID MUZZLE AI (Ver. 2.0)</h2>
        <div id="log">ãƒ­ã‚°: ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ä¸­...</div>
        
        <input type="file" id="fileInput" accept="image/*,video/*" hidden>
        <button id="uploadBtn" class="btn" disabled>ã‚¨ãƒ³ã‚¸ãƒ³èª­ã¿è¾¼ã¿ä¸­...</button>

        <div class="preview-box">
            <canvas id="canvas"></canvas>
            <video id="video" playsinline muted style="display:none;"></video>
        </div>
    </div>

    <script type="module">
        import { FaceDetector, FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('video');
        const fileInput = document.getElementById('fileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const logArea = document.getElementById('log');

        let detector;    // YOLOå½¹
        let landmarker;  // ç²¾å¯†è§£æå½¹
        let muzzleImg = new Image();
        muzzleImg.src = "muzzle.png"; // ãƒ•ã‚©ãƒ«ãƒ€å†…ã«ç½®ã„ã¦ãã ã•ã„

        function addLog(msg) {
            logArea.innerText += `> ${msg}\n`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        async function init() {
            try {
                addLog("WASMãƒªã‚¾ãƒ«ãƒãƒ¼ã‚’èª­ã¿è¾¼ã¿ä¸­...");
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                
                addLog("1/2: YOLOé¡”æ¤œå‡ºãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ä¸­...");
                detector = await FaceDetector.createFromOptions(vision, {
                    baseOptions: { 
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_detector/face_detector/float16/1/face_detector.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO"
                });

                addLog("2/2: ç²¾å¯†ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ä¸­...");
                landmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: { 
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numFaces: 1
                });

                addLog("ã‚·ã‚¹ãƒ†ãƒ èµ·å‹•å®Œäº†ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚");
                uploadBtn.disabled = false;
                uploadBtn.innerText = "å†™çœŸãƒ»å‹•ç”»ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰";
                uploadBtn.onclick = () => fileInput.click();
            } catch (e) { 
                addLog("è‡´å‘½çš„ã‚¨ãƒ©ãƒ¼: " + e.message); 
                console.error(e);
            }
        }

        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            if (file.type.startsWith('image/')) {
                const img = new Image();
                img.onload = () => {
                    canvas.width = img.width; canvas.height = img.height;
                    processSource(img);
                };
                img.src = url;
            } else {
                video.src = url;
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    video.play();
                    loop();
                };
            }
        };

        async function loop() {
            if (video.paused || video.ended) return;
            await processSource(video);
            requestAnimationFrame(loop);
        }

        async function processSource(source) {
            ctx.drawImage(source, 0, 0, canvas.width, canvas.height);
            const ts = performance.now();

            // YOLOå½¹ã§é¡”ã®æ ã‚’ç‰¹å®š
            const detectionResult = await detector.detectForVideo(source, ts);
            
            if (detectionResult.detections) {
                for (let i = 0; i < Math.min(detectionResult.detections.length, 2); i++) {
                    const face = detectionResult.detections[i];
                    const bbox = face.boundingBox;

                    // ROIã®åˆ‡ã‚Šå‡ºã— (25%ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°)
                    const pad = 0.25;
                    const roi = {
                        x: Math.max(0, bbox.originX - bbox.width * pad),
                        y: Math.max(0, bbox.originY - bbox.height * pad),
                        w: Math.min(canvas.width - bbox.originX, bbox.width * (1 + pad * 2)),
                        h: Math.min(canvas.height - bbox.originY, bbox.height * (1 + pad * 2))
                    };

                    // ROIå†…ã®ç²¾å¯†è§£æç”¨ãƒ“ãƒƒãƒˆãƒãƒƒãƒ—ã‚’ä½œæˆ
                    const roiCanvas = document.createElement('canvas');
                    roiCanvas.width = roi.w; roiCanvas.height = roi.h;
                    roiCanvas.getContext('2d').drawImage(canvas, roi.x, roi.y, roi.w, roi.h, 0, 0, roi.w, roi.h);

                    // ROIå†…ã®ã¿ã‚’ç²¾å¯†è§£æ
                    const landmarkResult = await landmarker.detectForVideo(roiCanvas, ts);

                    if (landmarkResult.faceLandmarks && landmarkResult.faceLandmarks.length > 0) {
                        drawMuzzleWithForecover(landmarkResult.faceLandmarks[0], roi);
                    }
                }
            }
        }

        function drawMuzzleWithForecover(landmarks, roi) {
            const toGlobal = (lm) => ({
                x: roi.x + (lm.x * roi.w),
                y: roi.y + (lm.y * roi.h),
                z: lm.z * roi.w
            });

            const noseTip = toGlobal(landmarks[4]);
            const jawL = toGlobal(landmarks[234]);
            const jawR = toGlobal(landmarks[454]);
            const eyeL = toGlobal(landmarks[33]);
            const eyeR = toGlobal(landmarks[263]);

            const faceCenterX = (jawL.x + jawR.x) / 2;
            const faceWidth2D = Math.abs(jawR.x - jawL.x);
            const yawFactor = (noseTip.x - faceCenterX) / (faceWidth2D / 2); // -1(å·¦) ï½ 1(å³)

            // å¥¥è¡Œãã‚’å«ã‚ãŸç‰©ç†å¹…ã®è¨ˆç®—
            const faceWidth3D = Math.hypot(jawR.x - jawL.x, (jawR.z - jawL.z));
            const angle = Math.atan2(eyeR.y - eyeL.y, eyeR.x - eyeL.x);

            // ã€æ‰‹å‰å°é¼»ã‚’éš ã™ãŸã‚ã®è£œæ­£ã€‘
            // é¡”ãŒæ–œã‚ã«ãªã‚‹ã»ã©å…¨ä½“ã®ã‚µã‚¤ã‚ºã‚’è†¨ã‚‰ã¾ã›ã‚‹
            const expansion = 1.0 + Math.abs(yawFactor) * 0.45; 
            const baseSize = faceWidth3D * 0.85 * expansion;
            
            // åœ§ç¸®ç‡ã®åˆ¶é™ï¼ˆãƒã‚ºãƒ«ãŒç´°ããªã‚Šã™ããªã„ã‚ˆã†ã«ï¼‰
            const squeezeFactor = Math.max(0.55, Math.cos(yawFactor * (Math.PI / 2.2)));
            const targetWidth = baseSize * squeezeFactor;
            const targetHeight = targetWidth / (muzzleImg.width / muzzleImg.height);

            // ãƒ€ãƒ–ãƒ«ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆå¥¥ã®å›ã‚Šè¾¼ã¿ + æ‰‹å‰ã¸ã®çªãå‡ºã—ï¼‰
            // yawFactorãŒãƒ—ãƒ©ã‚¹ï¼ˆå³å‘ãï¼‰ãªã‚‰ã€ãƒã‚ºãƒ«ã‚’ã•ã‚‰ã«å³ã¸æŠ¼ã—å‡ºã™
            const wrapAround = yawFactor * baseSize * 0.30;
            const foregroundPush = yawFactor * baseSize * 0.25; 
            const totalXOffset = wrapAround + foregroundPush;

            ctx.save();
            ctx.translate(noseTip.x, noseTip.y);
            ctx.rotate(angle);
            ctx.globalAlpha = 1.0;

            ctx.drawImage(
                muzzleImg, 
                -targetWidth / 2 + totalXOffset, 
                -targetHeight / 2 + (targetHeight * 0.18), 
                targetWidth, 
                targetHeight
            );
            ctx.restore();
        }

        init();
    </script>
</body>
</html>