<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Hybrid Cat Muzzle AI - Professional Edition</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #0f0f0f; color: #eee; text-align: center; margin: 0; padding: 20px; }
        .card { background: #1e1e1e; padding: 25px; border-radius: 24px; max-width: 800px; margin: auto; box-shadow: 0 10px 50px rgba(0,0,0,0.5); }
        #log { background: #000; color: #00ff66; font-family: 'Consolas', monospace; font-size: 12px; padding: 12px; height: 120px; overflow-y: auto; text-align: left; border-radius: 12px; margin: 15px 0; border: 1px solid #333; white-space: pre-wrap; }
        .preview-box { position: relative; border: 2px solid #333; border-radius: 16px; overflow: hidden; background: #000; min-height: 400px; }
        canvas { max-width: 100%; height: auto; display: block; margin: auto; }
        .btn { padding: 18px 36px; background: #6200ee; color: white; border: none; border-radius: 12px; font-weight: bold; cursor: pointer; margin: 10px; width: 90%; font-size: 16px; transition: 0.3s; }
        .btn:hover:not(:disabled) { background: #7722ff; transform: translateY(-2px); }
        .btn:disabled { background: #333; color: #777; cursor: wait; }
    </style>
</head>
<body>
    <div class="card">
        <h2>ğŸ± HYBRID MUZZLE AI v3.0</h2>
        <div id="log">ãƒ­ã‚°: åˆæœŸåŒ–ã‚’é–‹å§‹...</div>
        
        <input type="file" id="fileInput" accept="image/*,video/*" hidden>
        <button id="uploadBtn" class="btn" disabled>AIãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ä¸­...</button>

        <div class="preview-box">
            <canvas id="canvas"></canvas>
            <video id="video" playsinline muted style="display:none;"></video>
        </div>
    </div>

    <script type="module">
        import { FaceDetector, FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('video');
        const fileInput = document.getElementById('fileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const logArea = document.getElementById('log');

        let detector;    // YOLOå½¹å‰²: åºƒåŸŸæ¤œå‡º
        let landmarker;  // ç²¾å¯†å½¹å‰²: ROIå†…è§£æ
        let muzzleImg = new Image();
        muzzleImg.src = "muzzle.png"; // åŒãƒ•ã‚©ãƒ«ãƒ€ã®PNG

        function addLog(msg) {
            const time = new Date().toLocaleTimeString();
            logArea.innerText += `[${time}] ${msg}\n`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        async function init() {
            try {
                addLog("WASMã‚¨ãƒ³ã‚¸ãƒ³ã‚’èª­ã¿è¾¼ã¿ä¸­...");
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                
                // 1. YOLOå½¹å‰² (FaceDetector) ã®ãƒ­ãƒ¼ãƒ‰
                addLog("ãƒ¢ãƒ‡ãƒ«1/2: é¡”æ¤œå‡ºå™¨ã‚’ãƒ­ãƒ¼ãƒ‰ä¸­...");
                detector = await FaceDetector.createFromOptions(vision, {
                    baseOptions: { 
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_detector/face_detector/float16/1/face_detector.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO"
                });

                // 2. ç²¾å¯†è§£æå½¹å‰² (FaceLandmarker) ã®ãƒ­ãƒ¼ãƒ‰
                addLog("ãƒ¢ãƒ‡ãƒ«2/2: ç²¾å¯†è§£æå™¨ã‚’ãƒ­ãƒ¼ãƒ‰ä¸­...");
                landmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: { 
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "IMAGE", // ROIåˆ‡ã‚Šå‡ºã—ç”»åƒ(IMAGEå½¢å¼)ã‚’è§£æã™ã‚‹ãŸã‚
                    numFaces: 1
                });

                addLog("ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ã‚¨ãƒ³ã‚¸ãƒ³æº–å‚™å®Œäº†ã€‚");
                uploadBtn.disabled = false;
                uploadBtn.innerText = "å†™çœŸãƒ»å‹•ç”»ã‚’é¸æŠã—ã¦é–‹å§‹";
                uploadBtn.onclick = () => fileInput.click();
            } catch (e) { 
                addLog("è‡´å‘½çš„ã‚¨ãƒ©ãƒ¼: " + e.message); 
                console.error(e);
            }
        }

        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            if (file.type.startsWith('image/')) {
                const img = new Image();
                img.onload = () => {
                    canvas.width = img.width; canvas.height = img.height;
                    processHybridFrame(img);
                };
                img.src = url;
            } else {
                video.src = url;
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    video.play();
                    requestAnimationFrame(renderLoop);
                };
            }
        };

        async function renderLoop() {
            if (video.paused || video.ended) return;
            await processHybridFrame(video);
            requestAnimationFrame(renderLoop);
        }

        // ROIè§£æç”¨ã®ä½œæ¥­ç”¨ã‚­ãƒ£ãƒ³ãƒã‚¹
        const roiCanvas = document.createElement('canvas');
        const roiCtx = roiCanvas.getContext('2d');

        async function processHybridFrame(source) {
            // ãƒ¡ã‚¤ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ã«æç”»
            ctx.drawImage(source, 0, 0, canvas.width, canvas.height);

            // STEP 1: YOLOå½¹å‰²ã§è¦‹ã¤ã‘ã‚‹
            const detectionResult = await detector.detectForVideo(source, performance.now());
            
            if (detectionResult.detections) {
                for (const detection of detectionResult.detections) {
                    const bbox = detection.boundingBox;

                    // STEP 2: ROIåˆ‡ã‚Šå‡ºã— (å‘¨è¾ºã‚’30%ä½™è£•æŒãŸã›ã¦MediaPipeã®èªè­˜ã‚’åŠ©ã‘ã‚‹)
                    const pad = 0.3;
                    const roi = {
                        x: Math.max(0, bbox.originX - bbox.width * pad),
                        y: Math.max(0, bbox.originY - bbox.height * pad),
                        w: Math.min(canvas.width - (bbox.originX - bbox.width * pad), bbox.width * (1 + pad * 2)),
                        h: Math.min(canvas.height - (bbox.originY - bbox.height * pad), bbox.height * (1 + pad * 2))
                    };

                    roiCanvas.width = roi.w; roiCanvas.height = roi.h;
                    roiCtx.drawImage(canvas, roi.x, roi.y, roi.w, roi.h, 0, 0, roi.w, roi.h);

                    // STEP 3: ç²¾å¯†è§£æ
                    const landmarkResult = landmarker.detect(roiCanvas);

                    if (landmarkResult.faceLandmarks && landmarkResult.faceLandmarks.length > 0) {
                        drawEnhancedMuzzle(landmarkResult.faceLandmarks[0], roi);
                    }
                }
            }
        }

        function drawEnhancedMuzzle(landmarks, roi) {
            // ROIãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚­ãƒ£ãƒ³ãƒã‚¹åº§æ¨™ã«ãƒãƒƒãƒ”ãƒ³ã‚°
            const toGlobal = (lm) => ({
                x: roi.x + (lm.x * roi.w),
                y: roi.y + (lm.y * roi.h),
                z: lm.z * roi.w
            });

            const noseTip = toGlobal(landmarks[4]);
            const jawL = toGlobal(landmarks[234]);
            const jawR = toGlobal(landmarks[454]);
            const eyeL = toGlobal(landmarks[33]);
            const eyeR = toGlobal(landmarks[263]);

            const faceCenterX = (jawL.x + jawR.x) / 2;
            const faceWidth2D = Math.abs(jawR.x - jawL.x);
            const yawFactor = (noseTip.x - faceCenterX) / (faceWidth2D / 2); // -1.0(å·¦) ï½ 1.0(å³)

            // å¥¥è¡Œãã‚’è€ƒæ…®ã—ãŸ3Då¹…
            const faceWidth3D = Math.hypot(jawR.x - jawL.x, (jawR.z - jawL.z));
            const angle = Math.atan2(eyeR.y - eyeL.y, eyeR.x - eyeL.x);

            // ã€æ‰‹å‰å´ã‚«ãƒãƒ¼å¼·åŒ–ãƒ­ã‚¸ãƒƒã‚¯ã€‘
            // æ¨ªã‚’å‘ãã»ã©ã€ãƒã‚ºãƒ«ã‚’æ‰‹å‰å´ã«è†¨ã‚‰ã¾ã›ã‚‹ (Expansion)
            const expansion = 1.0 + Math.abs(yawFactor) * 0.5; 
            const baseSize = faceWidth3D * 0.8 * expansion;
            
            const squeezeFactor = Math.max(0.5, Math.cos(yawFactor * (Math.PI / 2.2)));
            const targetWidth = baseSize * squeezeFactor;
            const targetHeight = targetWidth / (muzzleImg.width / muzzleImg.height);

            // æ‰‹å‰å´ã®é¼»ã‚’è¦‹ãˆãªãã™ã‚‹ãŸã‚ã®å¼·åŠ›ãªã‚ªãƒ•ã‚»ãƒƒãƒˆ
            // yawFactorãŒãƒ—ãƒ©ã‚¹ï¼ˆå³å‘ãï¼‰ãªã‚‰ã€å³æ–¹å‘ï¼ˆæ‰‹å‰å´ï¼‰ã«ãƒã‚ºãƒ«ã‚’å¤§ããçªãå‡ºã™
            const wrapAround = yawFactor * baseSize * 0.35; 
            const foregroundShield = yawFactor * baseSize * 0.30; 
            const totalXOffset = wrapAround + foregroundShield;

            ctx.save();
            ctx.translate(noseTip.x, noseTip.y);
            ctx.rotate(angle);
            
            ctx.globalAlpha = 1.0; // å®Œå…¨ã«éš ã™ãŸã‚ã«ä¸é€æ˜
            ctx.drawImage(
                muzzleImg, 
                -targetWidth / 2 + totalXOffset, 
                -targetHeight / 2 + (targetHeight * 0.18), 
                targetWidth, 
                targetHeight
            );
            
            ctx.restore();
        }

        init();
    </script>
</body>
</html>